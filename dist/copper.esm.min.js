var F0=function(Q,X){const Z=Object.create(null),J=Q.split(",");for(let $=0;$<J.length;$++)Z[J[$]]=!0;return X?($)=>!!Z[$.toLowerCase()]:($)=>!!Z[$]};var b=Object.freeze({}),OX=Object.freeze([]),t=()=>{},jQ=()=>!1;var w=Object.assign,FQ=(Q,X)=>{const Z=Q.indexOf(X);if(Z>-1)Q.splice(Z,1)},zX=Object.prototype.hasOwnProperty,E=(Q,X)=>zX.call(Q,X),j=Array.isArray,v=(Q)=>O0(Q)==="[object Map]",OQ=(Q)=>O0(Q)==="[object Set]";var F=(Q)=>typeof Q==="function",$0=(Q)=>typeof Q==="string",Y0=(Q)=>typeof Q==="symbol",V=(Q)=>Q!==null&&typeof Q==="object",zQ=(Q)=>{return(V(Q)||F(Q))&&F(Q.then)&&F(Q.catch)},AX=Object.prototype.toString,O0=(Q)=>AX.call(Q),z0=(Q)=>{return O0(Q).slice(8,-1)},AQ=(Q)=>O0(Q)==="[object Object]",A0=(Q)=>$0(Q)&&Q!=="NaN"&&Q[0]!=="-"&&""+parseInt(Q,10)===Q;var T0=(Q)=>{const X=Object.create(null);return(Z)=>{return X[Z]||(X[Z]=Q(Z))}},TX=/-(\w)/g,PX=T0((Q)=>{return Q.replace(TX,(X,Z)=>Z?Z.toUpperCase():"")}),RX=/\B([A-Z])/g,NX=T0((Q)=>Q.replace(RX,"-$1").toLowerCase()),P0=T0((Q)=>{return Q.charAt(0).toUpperCase()+Q.slice(1)}),TQ=T0((Q)=>{return Q?`on${P0(Q)}`:""}),C=(Q,X)=>!Object.is(Q,X);var l0=(Q,X,Z)=>{Object.defineProperty(Q,X,{configurable:!0,enumerable:!1,value:Z})};var _Q,R0=()=>{return _Q||(_Q=typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:{})};var IX="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";var tZ=F0(IX+",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");var PQ=function(Q,...X){console.warn(`[Vue warn] ${Q}`,...X)};var VX=function(Q,X=fQ){if(X&&X.active)X.effects.push(Q)},s0=function(){return fQ};var RQ=function(Q){const{deps:X}=Q;if(X.length){for(let Z=0;Z<X.length;Z++)X[Z].delete(Q);X.length=0}};var x0=function(){SQ.push(m),m=!1};var f0=function(){const Q=SQ.pop();m=Q===void 0?!0:Q},P=function(Q,X,Z){if(m&&T){let J=d0.get(Q);if(!J)d0.set(Q,J=new Map);let $=J.get(Z);if(!$)J.set(Z,$=r0());gQ($,{effect:T,target:Q,type:X,key:Z})}},gQ=function(Q,X){let Z=!1;if(q0<=c0){if(!kQ(Q))Q.n|=l,Z=!CQ(Q)}else Z=!Q.has(T);if(Z){if(Q.add(T),T.deps.push(Q),T.onTrack)T.onTrack(w({effect:T},X))}},k=function(Q,X,Z,J,$,Y){const q=d0.get(Q);if(!q)return;let D=[];if(X==="clear")D=[...q.values()];else if(Z==="length"&&j(Q)){const L=Number(J);q.forEach((B,U)=>{if(U==="length"||!Y0(U)&&U>=L)D.push(B)})}else{if(Z!==void 0)D.push(q.get(Z));switch(X){case"add":if(!j(Q)){if(D.push(q.get(r)),v(Q))D.push(q.get(p0))}else if(A0(Z))D.push(q.get("length"));break;case"delete":if(!j(Q)){if(D.push(q.get(r)),v(Q))D.push(q.get(p0))}break;case"set":if(v(Q))D.push(q.get(r));break}}const W={target:Q,type:X,key:Z,newValue:J,oldValue:$,oldTarget:Y};if(D.length===1){if(D[0])i0(D[0],W)}else{const L=[];for(let B of D)if(B)L.push(...B);i0(r0(L),W)}},i0=function(Q,X){const Z=j(Q)?Q:[...Q];for(let J of Z)if(J.computed)NQ(J,X);for(let J of Z)if(!J.computed)NQ(J,X)},NQ=function(Q,X){if(Q!==T||Q.allowRecurse){if(Q.onTrigger)Q.onTrigger(w({effect:Q},X));if(Q.scheduler)Q.scheduler();else Q.run()}};var fX=function(){const Q={};return["includes","indexOf","lastIndexOf"].forEach((X)=>{Q[X]=function(...Z){const J=M(this);for(let Y=0,q=this.length;Y<q;Y++)P(J,"get",Y+"");const $=J[X](...Z);if($===-1||$===!1)return J[X](...Z.map(M));else return $}}),["push","pop","shift","unshift","splice"].forEach((X)=>{Q[X]=function(...Z){x0();const J=M(this)[X].apply(this,Z);return f0(),J}}),Q},CX=function(Q){const X=M(this);return P(X,"has",Q),X.hasOwnProperty(Q)},N0=function(Q,X,Z=!1,J=!1){Q=Q.__v_raw;const $=M(Q),Y=M(X);if(!Z){if(C(X,Y))P($,"get",X);P($,"get",Y)}const{has:q}=C0($),D=J?t0:Z?XQ:U0;if(q.call($,X))return D(Q.get(X));else if(q.call($,Y))return D(Q.get(Y));else if(Q!==$)Q.get(X)},I0=function(Q,X=!1){const Z=this.__v_raw,J=M(Z),$=M(Q);if(!X){if(C(Q,$))P(J,"has",Q);P(J,"has",$)}return Q===$?Z.has(Q):Z.has(Q)||Z.has($)},V0=function(Q,X=!1){return Q=Q.__v_raw,!X&&P(M(Q),"iterate",r),Reflect.get(Q,"size",Q)},VQ=function(Q){Q=M(Q);const X=M(this);if(!C0(X).has.call(X,Q))X.add(Q),k(X,"add",Q,Q);return this},bQ=function(Q,X){X=M(X);const Z=M(this),{has:J,get:$}=C0(Z);let Y=J.call(Z,Q);if(!Y)Q=M(Q),Y=J.call(Z,Q);else vQ(Z,J,Q);const q=$.call(Z,Q);if(Z.set(Q,X),!Y)k(Z,"add",Q,X);else if(C(X,q))k(Z,"set",Q,X,q);return this},wQ=function(Q){const X=M(this),{has:Z,get:J}=C0(X);let $=Z.call(X,Q);if(!$)Q=M(Q),$=Z.call(X,Q);else vQ(X,Z,Q);const Y=J?J.call(X,Q):void 0,q=X.delete(Q);if($)k(X,"delete",Q,void 0,Y);return q},xQ=function(){const Q=M(this),X=Q.size!==0,Z=v(Q)?new Map(Q):new Set(Q),J=Q.clear();if(X)k(Q,"clear",void 0,void 0,Z);return J},b0=function(Q,X){return function Z(J,$){const Y=this,q=Y.__v_raw,D=M(q),W=X?t0:Q?XQ:U0;return!Q&&P(D,"iterate",r),q.forEach((L,B)=>{return J.call($,W(L),W(B),Y)})}},w0=function(Q,X,Z){return function(...J){const $=this.__v_raw,Y=M($),q=v(Y),D=Q==="entries"||Q===Symbol.iterator&&q,W=Q==="keys"&&q,L=$[Q](...J),B=Z?t0:X?XQ:U0;return!X&&P(Y,"iterate",W?p0:r),{next(){const{value:U,done:K}=L.next();return K?{value:U,done:K}:{value:D?[B(U[0]),B(U[1])]:B(U),done:K}},[Symbol.iterator](){return this}}}},u=function(Q){return function(...X){{const Z=X[0]?`on key "${X[0]}" `:"";console.warn(`${P0(Q)} operation ${Z}failed: target is readonly.`,M(this))}return Q==="delete"?!1:this}},yX=function(){const Q={get(Y){return N0(this,Y)},get size(){return V0(this)},has:I0,add:VQ,set:bQ,delete:wQ,clear:xQ,forEach:b0(!1,!1)},X={get(Y){return N0(this,Y,!1,!0)},get size(){return V0(this)},has:I0,add:VQ,set:bQ,delete:wQ,clear:xQ,forEach:b0(!1,!0)},Z={get(Y){return N0(this,Y,!0)},get size(){return V0(this,!0)},has(Y){return I0.call(this,Y,!0)},add:u("add"),set:u("set"),delete:u("delete"),clear:u("clear"),forEach:b0(!0,!1)},J={get(Y){return N0(this,Y,!0,!0)},get size(){return V0(this,!0)},has(Y){return I0.call(this,Y,!0)},add:u("add"),set:u("set"),delete:u("delete"),clear:u("clear"),forEach:b0(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach((Y)=>{Q[Y]=w0(Y,!1,!1),Z[Y]=w0(Y,!0,!1),X[Y]=w0(Y,!1,!0),J[Y]=w0(Y,!0,!0)}),[Q,Z,X,J]},n0=function(Q,X){const Z=X?Q?mX:uX:Q?vX:hX;return(J,$,Y)=>{if($==="__v_isReactive")return!Q;else if($==="__v_isReadonly")return Q;else if($==="__v_raw")return J;return Reflect.get(E(Z,$)&&($ in J)?Z:J,$,Y)}},vQ=function(Q,X,Z){const J=M(Z);if(J!==Z&&X.call(Q,J)){const $=z0(Q);console.warn(`Reactive ${$} contains both the raw and reactive versions of the same object${$==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}},iX=function(Q){switch(Q){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}},sX=function(Q){return Q.__v_skip||!Object.isExtensible(Q)?0:iX(z0(Q))},L0=function(Q){if(S(Q))return Q;return e0(Q,!1,kX,lX,uQ)};var g=function(Q){return e0(Q,!0,SX,dX,mQ)},n=function(Q){return e0(Q,!0,gX,cX,lQ)},e0=function(Q,X,Z,J,$){if(!V(Q))return console.warn(`value cannot be made reactive: ${String(Q)}`),Q;if(Q.__v_raw&&!(X&&Q.__v_isReactive))return Q;const Y=$.get(Q);if(Y)return Y;const q=sX(Q);if(q===0)return Q;const D=new Proxy(Q,q===2?J:Z);return $.set(Q,D),D},d=function(Q){if(S(Q))return d(Q.__v_raw);return!!(Q&&Q.__v_isReactive)},S=function(Q){return!!(Q&&Q.__v_isReadonly)},e=function(Q){return!!(Q&&Q.__v_isShallow)};var M=function(Q){const X=Q&&Q.__v_raw;return X?M(X):Q},QQ=function(Q){return l0(Q,"__v_skip",!0),Q},dQ=function(Q){if(m&&T)Q=M(Q),gQ(Q.dep||(Q.dep=r0()),{target:Q,type:"get",key:"value"})},cQ=function(Q,X){Q=M(Q);const Z=Q.dep;if(Z)i0(Z,{target:Q,type:"set",key:"value",newValue:X})},z=function(Q){return!!(Q&&Q.__v_isRef===!0)},c=function(Q){return rX(Q,!1)};var rX=function(Q,X){if(z(Q))return Q;return new pQ(Q,X)};var Q0=function(Q){return z(Q)?Q.value:Q};var ZQ=function(Q){return d(Q)?Q:new Proxy(Q,aX)};var sQ=function(Q,X,Z=!1){let J,$;const Y=F(Q);if(Y)J=Q,$=()=>{console.warn("Write operation failed: computed value is readonly")};else J=Q.get,$=Q.set;const q=new iQ(J,$,Y||!$,Z);if(X&&!Z)q.effect.onTrack=X.onTrack,q.effect.onTrigger=X.onTrigger;return q};var fQ;var r0=(Q)=>{const X=new Set(Q);return X.w=0,X.n=0,X},CQ=(Q)=>(Q.w&l)>0,kQ=(Q)=>(Q.n&l)>0,bX=({deps:Q})=>{if(Q.length)for(let X=0;X<Q.length;X++)Q[X].w|=l},wX=(Q)=>{const{deps:X}=Q;if(X.length){let Z=0;for(let J=0;J<X.length;J++){const $=X[J];if(CQ($)&&!kQ($))$.delete(Q);else X[Z++]=$;$.w&=~l,$.n&=~l}X.length=Z}},d0=new WeakMap,q0=0,l=1,c0=30,T,r=Symbol("iterate"),p0=Symbol("Map key iterate");class D0{constructor(Q,X=null,Z){this.fn=Q,this.scheduler=X,this.active=!0,this.deps=[],this.parent=void 0,VX(this,Z)}run(){if(!this.active)return this.fn();let Q=T,X=m;while(Q){if(Q===this)return;Q=Q.parent}try{if(this.parent=T,T=this,m=!0,l=1<<++q0,q0<=c0)bX(this);else RQ(this);return this.fn()}finally{if(q0<=c0)wX(this);if(l=1<<--q0,T=this.parent,m=X,this.parent=void 0,this.deferStop)this.stop()}}stop(){if(T===this)this.deferStop=!0;else if(this.active){if(RQ(this),this.onStop)this.onStop();this.active=!1}}}var m=!0,SQ=[],xX=F0("__proto__,__v_isRef,__isVue"),yQ=new Set(Object.getOwnPropertyNames(Symbol).filter((Q)=>Q!=="arguments"&&Q!=="caller").map((Q)=>Symbol[Q]).filter(Y0)),IQ=fX();class a0{constructor(Q=!1,X=!1){this._isReadonly=Q,this._shallow=X}get(Q,X,Z){const J=this._isReadonly,$=this._shallow;if(X==="__v_isReactive")return!J;else if(X==="__v_isReadonly")return J;else if(X==="__v_isShallow")return $;else if(X==="__v_raw"&&Z===(J?$?lQ:mQ:$?pX:uQ).get(Q))return Q;const Y=j(Q);if(!J){if(Y&&E(IQ,X))return Reflect.get(IQ,X,Z);if(X==="hasOwnProperty")return CX}const q=Reflect.get(Q,X,Z);if(Y0(X)?yQ.has(X):xX(X))return q;if(!J)P(Q,"get",X);if($)return q;if(z(q))return Y&&A0(X)?q:q.value;if(V(q))return J?g(q):L0(q);return q}}class hQ extends a0{constructor(Q=!1){super(!1,Q)}set(Q,X,Z,J){let $=Q[X];if(S($)&&z($)&&!z(Z))return!1;if(!this._shallow){if(!e(Z)&&!S(Z))$=M($),Z=M(Z);if(!j(Q)&&z($)&&!z(Z))return $.value=Z,!0}const Y=j(Q)&&A0(X)?Number(X)<Q.length:E(Q,X),q=Reflect.set(Q,X,Z,J);if(Q===M(J)){if(!Y)k(Q,"add",X,Z);else if(C(Z,$))k(Q,"set",X,Z,$)}return q}deleteProperty(Q,X){const Z=E(Q,X),J=Q[X],$=Reflect.deleteProperty(Q,X);if($&&Z)k(Q,"delete",X,void 0,J);return $}has(Q,X){const Z=Reflect.has(Q,X);if(!Y0(X)||!yQ.has(X))P(Q,"has",X);return Z}ownKeys(Q){return P(Q,"iterate",j(Q)?"length":r),Reflect.ownKeys(Q)}}class o0 extends a0{constructor(Q=!1){super(!0,Q)}set(Q,X){return PQ(`Set operation on key "${String(X)}" failed: target is readonly.`,Q),!0}deleteProperty(Q,X){return PQ(`Delete operation on key "${String(X)}" failed: target is readonly.`,Q),!0}}var kX=new hQ,SX=new o0;var gX=new o0(!0),t0=(Q)=>Q,C0=(Q)=>Reflect.getPrototypeOf(Q),[hX,vX,uX,mX]=yX(),lX={get:n0(!1,!1)};var dX={get:n0(!0,!1)},cX={get:n0(!0,!0)},uQ=new WeakMap,pX=new WeakMap,mQ=new WeakMap,lQ=new WeakMap,U0=(Q)=>V(Q)?L0(Q):Q,XQ=(Q)=>V(Q)?g(Q):Q;class pQ{constructor(Q,X){this.__v_isShallow=X,this.dep=void 0,this.__v_isRef=!0,this._rawValue=X?Q:M(Q),this._value=X?Q:U0(Q)}get value(){return dQ(this),this._value}set value(Q){const X=this.__v_isShallow||e(Q)||S(Q);if(Q=X?Q:M(Q),C(Q,this._rawValue))this._rawValue=Q,this._value=X?Q:U0(Q),cQ(this,Q)}}var aX={get:(Q,X,Z)=>Q0(Reflect.get(Q,X,Z)),set:(Q,X,Z,J)=>{const $=Q[X];if(z($)&&!z(Z))return $.value=Z,!0;else return Reflect.set(Q,X,Z,J)}};class iQ{constructor(Q,X,Z,J){this._setter=X,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new D0(Q,()=>{if(!this._dirty)this._dirty=!0,cQ(this)}),this.effect.computed=this,this.effect.active=this._cacheable=!J,this.__v_isReadonly=Z}get value(){const Q=M(this);if(dQ(Q),Q._dirty||!Q._cacheable)Q._dirty=!1,Q._value=Q.effect.run();return Q._value}set value(Q){this._setter(Q)}}var eX=function(Q){a.push(Q)},QZ=function(){a.pop()},O=function(Q,...X){x0();const Z=a.length?a[a.length-1].component:null,J=Z&&Z.appContext.config.warnHandler,$=XZ();if(J)o(J,Z,11,[Q+X.join(""),Z&&Z.proxy,$.map(({vnode:Y})=>`at <${BX(Z,Y.type)}>`).join("\n"),$]);else{const Y=[`[Vue warn]: ${Q}`,...X];if($.length)Y.push(`
`,...ZZ($));console.warn(...Y)}f0()},XZ=function(){let Q=a[a.length-1];if(!Q)return[];const X=[];while(Q){const Z=X[0];if(Z&&Z.vnode===Q)Z.recurseCount++;else X.push({vnode:Q,recurseCount:0});const J=Q.component&&Q.component.parent;Q=J&&J.vnode}return X},ZZ=function(Q){const X=[];return Q.forEach((Z,J)=>{X.push(...J===0?[]:[`
`],...JZ(Z))}),X},JZ=function({vnode:Q,recurseCount:X}){const Z=X>0?`... (${X} recursive calls)`:"",J=Q.component?Q.component.parent==null:!1,$=` at <${BX(Q.component,Q.type,J)}`,Y=">"+Z;return Q.props?[$,...$Z(Q.props),Y]:[$+Y]},$Z=function(Q){const X=[],Z=Object.keys(Q);if(Z.slice(0,3).forEach((J)=>{X.push(...JX(J,Q[J]))}),Z.length>3)X.push(" ...");return X},JX=function(Q,X,Z){if($0(X))return X=JSON.stringify(X),Z?X:[`${Q}=${X}`];else if(typeof X==="number"||typeof X==="boolean"||X==null)return Z?X:[`${Q}=${X}`];else if(z(X))return X=JX(Q,M(X.value),!0),Z?X:[`${Q}=Ref<`,X,">"];else if(F(X))return[`${Q}=fn${X.name?`<${X.name}>`:""}`];else return X=M(X),Z?X:[`${Q}=`,X]};var o=function(Q,X,Z,J){let $;try{$=J?Q(...J):Q()}catch(Y){$X(Y,X,Z)}return $},M0=function(Q,X,Z,J){if(F(Q)){const Y=o(Q,X,Z,J);if(Y&&zQ(Y))Y.catch((q)=>{$X(q,X,Z)});return Y}const $=[];for(let Y=0;Y<Q.length;Y++)$.push(M0(Q[Y],X,Z,J));return $},$X=function(Q,X,Z,J=!0){const $=X?X.vnode:null;if(X){let Y=X.parent;const q=X.proxy,D=WQ[Z];while(Y){const L=Y.ec;if(L){for(let B=0;B<L.length;B++)if(L[B](Q,q,D)===!1)return}Y=Y.parent}const W=X.appContext.config.errorHandler;if(W){o(W,null,10,[Q,q,D]);return}}YZ(Q,Z,$,J)},YZ=function(Q,X,Z,J=!0){{const $=WQ[X];if(Z)eX(Z);if(O(`Unhandled error${$?` during execution of ${$}`:""}`),Z)QZ();if(J)throw Q;else console.error(Q)}},UZ=function(Q){const X=KQ||YX;return Q?X.then(this?Q.bind(this):Q):X},DZ=function(Q){let X=i+1,Z=x.length;while(X<Z){const J=X+Z>>>1,$=x[J],Y=H0($);if(Y<Q||Y===Q&&$.pre)X=J+1;else Z=J}return X},MQ=function(Q){if(!x.length||!x.includes(Q,S0&&Q.allowRecurse?i+1:i)){if(Q.id==null)x.push(Q);else x.splice(DZ(Q.id),0,Q);qX()}},qX=function(){if(!S0&&!qQ)qQ=!0,KQ=YX.then(DX)};var UX=function(Q){if(!j(Q)){if(!f||!f.includes(Q,Q.allowRecurse?p+1:p))J0.push(Q)}else J0.push(...Q);qX()};var LZ=function(Q){if(J0.length){const X=[...new Set(J0)];if(J0.length=0,f){f.push(...X);return}f=X,Q=Q||new Map,f.sort((Z,J)=>H0(Z)-H0(J));for(p=0;p<f.length;p++){if(LX(Q,f[p]))continue;f[p]()}f=null,p=0}},DX=function(Q){qQ=!1,S0=!0,Q=Q||new Map,x.sort(WZ);const X=(Z)=>LX(Q,Z);try{for(i=0;i<x.length;i++){const Z=x[i];if(Z&&Z.active!==!1){if(X(Z))continue;o(Z,null,14)}}}finally{if(i=0,x.length=0,LZ(Q),S0=!1,KQ=null,x.length||J0.length)DX(Q)}},LX=function(Q,X){if(!Q.has(X))Q.set(X,1);else{const Z=Q.get(X);if(Z>qZ){const J=X.ownerInstance,$=J&&MX(J.type);return O(`Maximum recursive updates exceeded${$?` in component <${$}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`),!0}else Q.set(X,Z+1)}};var KZ=function(Q,X){if(g0.has(Q))return!1;return g0.set(Q,{initialDef:B0(X),instances:new Set}),!0},B0=function(Q){return CZ(Q)?Q.__vccOpts:Q},MZ=function(Q,X){const Z=g0.get(Q);if(!Z)return;Z.initialDef.render=X,[...Z.instances].forEach((J)=>{if(X)J.render=X,B0(J.type).render=X;J.renderCache=[],rQ=!0,J.update(),rQ=!1})},BZ=function(Q,X){const Z=g0.get(Q);if(!Z)return;X=B0(X),aQ(Z.initialDef,X);const J=[...Z.instances];for(let $ of J){const Y=B0($.type);if(!W0.has(Y)){if(Y!==Z.initialDef)aQ(Y,X);W0.add(Y)}if($.appContext.propsCache.delete($.type),$.appContext.emitsCache.delete($.type),$.appContext.optionsCache.delete($.type),$.ceReload)W0.add(Y),$.ceReload(X.styles),W0.delete(Y);else if($.parent)MQ($.parent.update);else if($.appContext.reload)$.appContext.reload();else if(typeof window!=="undefined")window.location.reload();else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}UX(()=>{for(let $ of J)W0.delete(B0($.type))})},aQ=function(Q,X){w(Q,X);for(let Z in Q)if(Z!=="__file"&&!(Z in X))delete Q[Z]},JQ=function(Q){return(X,Z)=>{try{return Q(X,Z)}catch(J){console.error(J),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}};var HZ=function(){GZ=!0};var EZ=function(Q,X){if(X&&X.pendingBranch)if(j(Q))X.effects.push(...Q);else X.effects.push(Q);else UX(Q)};var BQ=function(Q,X,Z){if(!F(X))O("\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.");return WX(Q,X,Z)},WX=function(Q,X,{immediate:Z,deep:J,flush:$,onTrack:Y,onTrigger:q}=b){var D;if(!X){if(Z!==void 0)O('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');if(J!==void 0)O('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.')}const W=(H)=>{O("Invalid watch source: ",H,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},L=s0()===((D=y)==null?void 0:D.scope)?y:null;let B,U=!1,K=!1;if(z(Q))B=()=>Q.value,U=e(Q);else if(d(Q))B=()=>Q,J=!0;else if(j(Q))K=!0,U=Q.some((H)=>d(H)||e(H)),B=()=>Q.map((H)=>{if(z(H))return H.value;else if(d(H))return Z0(H);else if(F(H))return o(H,L,2);else W(H)});else if(F(Q))if(X)B=()=>o(Q,L,2);else B=()=>{if(L&&L.isUnmounted)return;if(G)G();return M0(Q,L,3,[_])};else B=t,W(Q);if(X&&J){const H=B;B=()=>Z0(H())}let G,_=(H)=>{G=I.onStop=()=>{o(H,L,4)}},A;if(HQ){if(_=t,!X)B();else if(Z)M0(X,L,3,[B(),K?[]:void 0,_]);if($==="sync"){const H=gZ();A=H.__watcherHandles||(H.__watcherHandles=[])}else return t}let N=K?new Array(Q.length).fill(k0):k0;const s=()=>{if(!I.active)return;if(X){const H=I.run();if(J||U||(K?H.some((jX,FX)=>C(jX,N[FX])):C(H,N))){if(G)G();M0(X,L,3,[H,N===k0?void 0:K&&N[0]===k0?[]:N,_]),N=H}}else I.run()};s.allowRecurse=!!X;let j0;if($==="sync")j0=s;else if($==="post")j0=()=>XX(s,L&&L.suspense);else{if(s.pre=!0,L)s.id=L.uid;j0=()=>MQ(s)}const I=new D0(B,j0);if(I.onTrack=Y,I.onTrigger=q,X)if(Z)s();else N=I.run();else if($==="post")XX(I.run.bind(I),L&&L.suspense);else I.run();const EQ=()=>{if(I.stop(),L&&L.scope)FQ(L.scope.effects,I)};if(A)A.push(EQ);return EQ},_Z=function(Q,X,Z){const J=this.proxy,$=$0(Q)?Q.includes(".")?jZ(J,Q):()=>J[Q]:Q.bind(J,J);let Y;if(F(X))Y=X;else Y=X.handler,Z=X;const q=y;LQ(this);const D=WX($,Y.bind(J),Z);if(q)LQ(q);else KX();return D},jZ=function(Q,X){const Z=X.split(".");return()=>{let J=Q;for(let $=0;$<Z.length&&J;$++)J=J[Z[$]];return J}},Z0=function(Q,X){if(!V(Q)||Q.__v_skip)return Q;if(X=X||new Set,X.has(Q))return Q;if(X.add(Q),z(Q))Z0(Q.value,X);else if(j(Q))for(let Z=0;Z<Q.length;Z++)Z0(Q[Z],X);else if(OQ(Q)||v(Q))Q.forEach((Z)=>{Z0(Z,X)});else if(AQ(Q))for(let Z in Q)Z0(Q[Z],X);return Q};var FZ=function(Q,X,Z=y,J=!1){if(Z){const $=Z[Q]||(Z[Q]=[]),Y=X.__weh||(X.__weh=(...q)=>{if(Z.isUnmounted)return;x0(),LQ(Z);const D=M0(X,Z,Q,q);return KX(),f0(),D});if(J)$.unshift(Y);else $.push(Y);return Y}else{const $=TQ(WQ[Q].replace(/ hook$/,""));O(`${$} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`+" If you are using async setup(), make sure to register lifecycle hooks before the first await statement.")}};var oQ=function(Q){return j(Q)?Q.reduce((X,Z)=>(X[Z]=null,X),{}):Q};var TZ=function(Q){const X=Q.type,{mixins:Z,extends:J}=X,{mixins:$,optionsCache:Y,config:{optionMergeStrategies:q}}=Q.appContext,D=Y.get(X);let W;if(D)W=D;else if(!$.length&&!Z&&!J)W=X;else{if(W={},$.length)$.forEach((L)=>y0(W,L,q,!0));y0(W,X,q)}if(V(X))Y.set(X,W);return W},y0=function(Q,X,Z,J=!1){const{mixins:$,extends:Y}=X;if(Y)y0(Q,Y,Z,!0);if($)$.forEach((q)=>y0(Q,q,Z,!0));for(let q in X)if(J&&q==="expose")O('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const D=PZ[q]||Z&&Z[q];Q[q]=D?D(Q[q],X[q]):X[q]}return Q},tQ=function(Q,X){if(!X)return Q;if(!Q)return X;return function Z(){return w(F(Q)?Q.call(this,this):Q,F(X)?X.call(this,this):X)}},RZ=function(Q,X){return K0(nQ(Q),nQ(X))},nQ=function(Q){if(j(Q)){const X={};for(let Z=0;Z<Q.length;Z++)X[Q[Z]]=Q[Z];return X}return Q},R=function(Q,X){return Q?[...new Set([].concat(Q,X))]:X},K0=function(Q,X){return Q?w(Object.create(null),Q,X):X},eQ=function(Q,X){if(Q){if(j(Q)&&j(X))return[...new Set([...Q,...X])];return w(Object.create(null),oQ(Q),oQ(X!=null?X:{}))}else return X},NZ=function(Q,X){if(!Q)return X;if(!X)return Q;const Z=w(Object.create(null),Q);for(let J in X)Z[J]=R(Q[J],X[J]);return Z},IZ=function(){return{app:null,config:{isNativeTag:jQ,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}};var VZ=function(Q,X,Z=!1){const J=y||UQ;if(J||QX){const $=J?J.parent==null?J.vnode.appContext&&J.vnode.appContext.provides:J.parent.provides:QX._context.provides;if($&&(Q in $))return $[Q];else if(arguments.length>1)return Z&&F(X)?X.call(J&&J.proxy):X;else O(`injection "${String(Q)}" not found.`)}else O("inject() can only be used inside setup() or functional components.")};var bZ=function(Q){return Q.vnode.shapeFlag&4};var wZ=function(Q){if(Q.exposed)return Q.exposeProxy||(Q.exposeProxy=new Proxy(ZQ(QQ(Q.exposed)),{get(X,Z){if(Z in X)return X[Z];else if(Z in G0)return G0[Z](Q)},has(X,Z){return(Z in X)||(Z in G0)}}))},MX=function(Q,X=!0){return F(Q)?Q.displayName||Q.name:Q.name||X&&Q.__name},BX=function(Q,X,Z=!1){let J=MX(X);if(!J&&X.__file){const $=X.__file.match(/([^/\\]+)\.\w+$/);if($)J=$[1]}if(!J&&Q&&Q.parent){const $=(Y)=>{for(let q in Y)if(Y[q]===X)return q};J=$(Q.components||Q.parent.type.components)||$(Q.appContext.components)}return J?fZ(J):Z?"App":"Anonymous"},CZ=function(Q){return F(Q)&&("__vccOpts"in Q)};var YQ=function(Q){return!!(Q&&Q.__v_isShallow)},GX=function(){if(typeof window==="undefined")return;const Q={style:"color:#3ba776"},X={style:"color:#0b1bc9"},Z={style:"color:#b62e24"},J={style:"color:#9d288c"},$={header(U){if(!V(U))return null;if(U.__isVue)return["div",Q,"VueInstance"];else if(z(U))return["div",{},["span",Q,B(U)],"<",D(U.value),">"];else if(d(U))return["div",{},["span",Q,YQ(U)?"ShallowReactive":"Reactive"],"<",D(U),`>${S(U)?" (readonly)":""}`];else if(S(U))return["div",{},["span",Q,YQ(U)?"ShallowReadonly":"Readonly"],"<",D(U),">"];return null},hasBody(U){return U&&U.__isVue},body(U){if(U&&U.__isVue)return["div",{},...Y(U.$)]}};function Y(U){const K=[];if(U.type.props&&U.props)K.push(q("props",M(U.props)));if(U.setupState!==b)K.push(q("setup",U.setupState));if(U.data!==b)K.push(q("data",M(U.data)));const G=W(U,"computed");if(G)K.push(q("computed",G));const _=W(U,"inject");if(_)K.push(q("injected",_));return K.push(["div",{},["span",{style:J.style+";opacity:0.66"},"$ (internal): "],["object",{object:U}]]),K}function q(U,K){if(K=w({},K),!Object.keys(K).length)return["span",{}];return["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},U],["div",{style:"padding-left:1.25em"},...Object.keys(K).map((G)=>{return["div",{},["span",J,G+": "],D(K[G],!1)]})]]}function D(U,K=!0){if(typeof U==="number")return["span",X,U];else if(typeof U==="string")return["span",Z,JSON.stringify(U)];else if(typeof U==="boolean")return["span",J,U];else if(V(U))return["object",{object:K?M(U):U}];else return["span",Z,String(U)]}function W(U,K){const G=U.type;if(F(G))return;const _={};for(let A in U.ctx)if(L(G,A,K))_[A]=U.ctx[A];return _}function L(U,K,G){const _=U[G];if(j(_)&&_.includes(K)||V(_)&&(K in _))return!0;if(U.extends&&L(U.extends,K,G))return!0;if(U.mixins&&U.mixins.some((A)=>L(A,K,G)))return!0}function B(U){if(YQ(U))return"ShallowRef";if(U.effect)return"ComputedRef";return"Ref"}if(window.devtoolsFormatters)window.devtoolsFormatters.push($);else window.devtoolsFormatters=[$]};var a=[],WQ={["sp"]:"serverPrefetch hook",["bc"]:"beforeCreate hook",["c"]:"created hook",["bm"]:"beforeMount hook",["m"]:"mounted hook",["bu"]:"beforeUpdate hook",["u"]:"updated",["bum"]:"beforeUnmount hook",["um"]:"unmounted hook",["a"]:"activated hook",["da"]:"deactivated hook",["ec"]:"errorCaptured hook",["rtc"]:"renderTracked hook",["rtg"]:"renderTriggered hook",[0]:"setup function",[1]:"render function",[2]:"watcher getter",[3]:"watcher callback",[4]:"watcher cleanup function",[5]:"native event handler",[6]:"component event handler",[7]:"vnode hook",[8]:"directive hook",[9]:"transition hook",[10]:"app errorHandler",[11]:"app warnHandler",[12]:"ref function",[13]:"async component loader",[14]:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"},S0=!1,qQ=!1,x=[],i=0,J0=[],f=null,p=0,YX=Promise.resolve(),KQ=null,qZ=100,H0=(Q)=>Q.id==null?Infinity:Q.id,WZ=(Q,X)=>{const Z=H0(Q)-H0(X);if(Z===0){if(Q.pre&&!X.pre)return-1;if(X.pre&&!Q.pre)return 1}return Z},rQ=!1,W0=new Set;R0().__VUE_HMR_RUNTIME__={createRecord:JQ(KZ),rerender:JQ(MZ),reload:JQ(BZ)};var g0=new Map;var UQ=null;var GZ=!1;var k0={},P4=Symbol("_leaveCb"),R4=Symbol("_enterCb");/*! #__NO_SIDE_EFFECTS__ *//*! #__NO_SIDE_EFFECTS__ */var h=(Q)=>(X,Z=y)=>(!HQ||Q==="sp")&&FZ(Q,(...J)=>X(...J),Z),N4=h("bm"),I4=h("m"),V4=h("bu"),b4=h("u"),w4=h("bum"),x4=h("um"),f4=h("sp"),C4=h("rtg"),k4=h("rtc");var S4=Symbol.for("v-ndc"),DQ=(Q)=>{if(!Q)return null;if(bZ(Q))return wZ(Q)||Q.proxy;return DQ(Q.parent)},G0=w(Object.create(null),{$:(Q)=>Q,$el:(Q)=>Q.vnode.el,$data:(Q)=>Q.data,$props:(Q)=>n(Q.props),$attrs:(Q)=>n(Q.attrs),$slots:(Q)=>n(Q.slots),$refs:(Q)=>n(Q.refs),$parent:(Q)=>DQ(Q.parent),$root:(Q)=>DQ(Q.root),$emit:(Q)=>Q.emit,$options:(Q)=>__VUE_OPTIONS_API__?TZ(Q):Q.type,$forceUpdate:(Q)=>Q.f||(Q.f=()=>MQ(Q.update)),$nextTick:(Q)=>Q.n||(Q.n=UZ.bind(Q.proxy)),$watch:(Q)=>__VUE_OPTIONS_API__?_Z.bind(Q):t}),OZ=(Q)=>Q==="_"||Q==="$",$Q=(Q,X)=>Q!==b&&!Q.__isScriptSetup&&E(Q,X),zZ={get({_:Q},X){const{ctx:Z,setupState:J,data:$,props:Y,accessCache:q,type:D,appContext:W}=Q;if(X==="__isVue")return!0;let L;if(X[0]!=="$"){const G=q[X];if(G!==void 0)switch(G){case 1:return J[X];case 2:return $[X];case 4:return Z[X];case 3:return Y[X]}else if($Q(J,X))return q[X]=1,J[X];else if($!==b&&E($,X))return q[X]=2,$[X];else if((L=Q.propsOptions[0])&&E(L,X))return q[X]=3,Y[X];else if(Z!==b&&E(Z,X))return q[X]=4,Z[X];else if(!__VUE_OPTIONS_API__||AZ)q[X]=0}const B=G0[X];let U,K;if(B){if(X==="$attrs")P(Q,"get",X),HZ();else if(X==="$slots")P(Q,"get",X);return B(Q)}else if((U=D.__cssModules)&&(U=U[X]))return U;else if(Z!==b&&E(Z,X))return q[X]=4,Z[X];else if(K=W.config.globalProperties,E(K,X))return K[X];else if(UQ&&(!$0(X)||X.indexOf("__v")!==0)){if($!==b&&OZ(X[0])&&E($,X))O(`Property ${JSON.stringify(X)} must be accessed via \$data because it starts with a reserved character ("\$" or "_") and is not proxied on the render context.`);else if(Q===UQ)O(`Property ${JSON.stringify(X)} was accessed during render but is not defined on instance.`)}},set({_:Q},X,Z){const{data:J,setupState:$,ctx:Y}=Q;if($Q($,X))return $[X]=Z,!0;else if($.__isScriptSetup&&E($,X))return O(`Cannot mutate <script setup> binding "${X}" from Options API.`),!1;else if(J!==b&&E(J,X))return J[X]=Z,!0;else if(E(Q.props,X))return O(`Attempting to mutate prop "${X}". Props are readonly.`),!1;if(X[0]==="$"&&(X.slice(1)in Q))return O(`Attempting to mutate public property "${X}". Properties starting with \$ are reserved and readonly.`),!1;else if(X in Q.appContext.config.globalProperties)Object.defineProperty(Y,X,{enumerable:!0,configurable:!0,value:Z});else Y[X]=Z;return!0},has({_:{data:Q,setupState:X,accessCache:Z,ctx:J,appContext:$,propsOptions:Y}},q){let D;return!!Z[q]||Q!==b&&E(Q,q)||$Q(X,q)||(D=Y[0])&&E(D,q)||E(J,q)||E(G0,q)||E($.config.globalProperties,q)},defineProperty(Q,X,Z){if(Z.get!=null)Q._.accessCache[X]=0;else if(E(Z,"value"))this.set(Q,X,Z.value,null);return Reflect.defineProperty(Q,X,Z)}};zZ.ownKeys=(Q)=>{return O("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(Q)};var AZ=!0,PZ={data:tQ,props:eQ,emits:eQ,methods:K0,computed:K0,beforeCreate:R,created:R,beforeMount:R,mounted:R,beforeUpdate:R,updated:R,beforeDestroy:R,beforeUnmount:R,destroyed:R,unmounted:R,activated:R,deactivated:R,errorCaptured:R,serverPrefetch:R,components:K0,directives:K0,watch:NZ,provide:tQ,inject:RZ};var QX=null;var XX=EZ;var g4=Symbol.for("v-fgt"),y4=Symbol.for("v-txt"),h4=Symbol.for("v-cmt"),v4=Symbol.for("v-stc");var u4=IZ();var y=null;var GQ,X0,ZX="__VUE_INSTANCE_SETTERS__";{if(!(X0=R0()[ZX]))X0=R0()[ZX]=[];X0.push((Q)=>y=Q),GQ=(Q)=>{if(X0.length>1)X0.forEach((X)=>X(Q));else X0[0](Q)}}var LQ=(Q)=>{GQ(Q),Q.scope.on()},KX=()=>{y&&y.scope.off(),GQ(null)};var HQ=!1;var xZ=/(?:^|[-_])(\w)/g,fZ=(Q)=>Q.replace(xZ,(X)=>X.toUpperCase()).replace(/[-_]/g,""),kZ=(Q,X)=>{return sQ(Q,X,HQ)},SZ=Symbol.for("v-scx"),gZ=()=>{{const Q=VZ(SZ);if(!Q)O("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");return Q}};var yZ=function(){GX()};yZ();class E0{element;props={};#Q=[];constructor(Q){this.element=Q}watch(...Q){const X=BQ(...Q);return this.#Q.push(X),X}listen(...Q){this.element.addEventListener(...Q);const X=()=>{this.element.removeEventListener(...Q)};return this.#Q.push(X),X}addWatcher(Q){this.#Q.push(Q)}destroy(){while(this.#Q.length>0)this.#Q.pop()();if(this.element){for(let Q of this.element.childNodes)Q._copper?.destroy();delete this.element._copper,this.element=null}}}var h0=function(Q){if(!Q._copper)Q._copper=new E0(Q)};function hZ(Q){const X=document.createElement(Q);return h0(X),X}function vZ(Q="svg"){const X=document.createElementNS("http://www.w3.org/2000/svg",Q);return h0(X),X}function uZ(Q){const X=typeof Q==="function",Z=document.createTextNode(X?"":Q??" ");if(h0(Z),X)Z._copper.watch(Q,(J)=>{Z.textContent=String(J)},{deep:!0,immediate:!0});return Z}function _0(){return document.createDocumentFragment()}function v0(Q=""){const X=document.createComment(Q);return h0(X),X}function mZ(Q,...X){return Q.append(...X),Q}var HX=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootdelegatesfocus"]);function u0(Q){return typeof Q==="object"&&Q!==null&&Q.constructor===Object}var m0=function(Q){const X=new Map;if(u0(Q)){for(let[Z,J]of Object.entries(Q))if(J)X.set(Z,J)}else if(Array.isArray(Q))for(let Z of Q)X.set(Z,Z);return X},EX=function(Q,X,Z,J){if(HX.has(X))if(Z)Q.setAttribute(X,"");else Q.removeAttribute(X);else if(typeof Z==="string")Q.setAttribute(X,Z);else if(X==="class"){const $=m0(J);for(let Y of m0(Z).keys())Q.classList.add(Y),$.delete(Y);for(let Y of $.keys())Q.classList.remove(Y)}else if(X==="style"){const $=m0(J);for(let[Y,q]of m0(Z))Q.style.setProperty(Y,q),$.delete(Y);for(let Y of $.keys())Q.style.removeProperty(Y)}else if(Z!==null&&Z!==void 0)Q.setAttribute(X,Z);else Q.removeAttribute(X)};function lZ(Q,...X){for(let Z=0;Z<X.length;Z+=2){const J=X[Z],$=X[Z+1];if(typeof $==="function")Q._copper.watch($,(Y,q)=>{EX(Q,J,Q0(Y),Q0(q))},{deep:!0,immediate:!0});else EX(Q,J,$)}return Q}var dZ=function(Q,X){let Z=X,J=[];if(typeof Q==="function")J=Q();if(J.length===0)J.push(X);else Z=_0(),Z.append(...J);return[Z,J]};function cZ(Q,X){const Z=v0(),J=Z._copper,$=[Z];return setTimeout(()=>{J.watch(Q,(Y)=>{const[q,D]=dZ(X[Y],Z);while($.length>0){const W=$.pop();if($.length===0)W.replaceWith(q);else W.remove();if(W!==Z)W._copper?.destroy()}$.push(...D)},{immediate:!0})}),J.addWatcher(()=>{for(let Y of $)Y.remove(),Y._copper?.destroy();$.length=0}),Z}var pZ=function(Q){if(u0(Q))return Object.entries(Q);if(Array.isArray(Q)||Q instanceof Map||Q instanceof Set)return Q.entries();if(typeof Q==="number"){const X=[];for(let Z=0;Z<Q;Z++)X.push([Z,Z]);return X}throw new TypeError("Cannot iterate over value")};function iZ(Q,X,Z){const J=v0(),$=J._copper;let Y=J;const q=new Map,D=typeof X==="function";return setTimeout(()=>{$.watch(Q,(W)=>{const L=new Set(q.keys());if(Y!==J)Y.parentNode.insertBefore(J,Y);const B=_0();for(let[U,K]of pZ(W)){const G=D?X(K,U):Symbol("");L.delete(G);let _,A,N;if(q.has(G))({ref_key:_,ref_value:A,elements:N}=q.get(G)),_.value=U,A.value=K;else _=c(U),A=c(K),N=Z(g(A),g(_));if(N.length===0)continue;B.append(...N),q.set(G,{ref_key:_,ref_value:A,elements:N})}for(let U of L){const{elements:K}=q.get(U);for(let G of K)G.remove(),G._copper?.destroy();q.delete(U)}if(B.childNodes.length===0)Y=J;else Y=B.firstChild,J.replaceWith(B)},{deep:!0,immediate:!0})}),$.addWatcher(()=>{for(let{elements:W}of q.values())for(let L of W)L.remove(),L._copper?.destroy();q.clear()}),J}function sZ(Q,X,Z){return Q._copper.watch(X,(J)=>{Q.value=J},{deep:!0,immediate:!0}),Q._copper.listen("input",()=>{Z(Q.value)}),Q}function rZ(Q,...X){const Z=Q._copper;for(let J=0;J<X.length;J+=2){const $=X[J],Y=X[J+1],q=c(),D=Z.propsValidators?.[$],W=typeof D==="function";Z.watch(Y,(L)=>{if(W&&D(L)!==!0)console.error(`Invalid value for property ${$} on component`,Q);else q.value=L},{immediate:!0}),Z.props[$]=g(q)}return Q}function aZ(Q,...X){for(let Z=0;Z<X.length;Z+=3){const J=X[Z],$=X[Z+1],Y=new Set(X[Z+2]),q={};if(Y.has("once"))q.once=!0;if(Y.has("passive"))q.passive=!0;if(Y.has("capture"))q.capture=!0;const D=[J,(W)=>{if(Y.has("shift")&&!W.shiftKey)return;if(Y.has("alt")&&!W.altKey)return;if(Y.has("ctrl")&&!W.ctrlKey)return;if(Y.has("meta")&&!W.metaKey)return;if(Y.has("prevent"))W.preventDefault();if(Y.has("stop"))W.stopPropagation();$(Y.has(".component")?W.detail:W)}];if(Object.keys(q).length>0)D.push(q);Q._copper.listen(...D)}return Q}var oZ=function(Q,X){const Z=document.createElement("style");Z.setAttribute("copper-component",Q),Z.textContent=X,document.head.append(Z)};class _X extends HTMLElement{root;constructor(Q={}){super();if(typeof this.constructor.css==="string")oZ(this.tagName.toLowerCase(),this.constructor.css),delete this.constructor.css;this.innerHTML="";const X=Q.shadow??"none";switch(X){case"open":case"closed":this.root=this.attachShadow({mode:X});break;case"none":this.root=this;break;default:throw new Error(`Invalid "shadow" option: "${Q.shadow}".`)}this._copper=new E0(this)}#Q=!1;init(Q){try{this.render(Q)}catch(X){console.error(X)}}render(...Q){this.root.append(...Q)}#X=!1;connectedCallback(){if(this.#X===!1){if(this.#X=!0,!this.#Q)this.#Q=!0,this.init();this.emit("#mounted")}}disconnectedCallback(){setTimeout(()=>{if(this.isConnected===!1)this.#X=!1,this.onUnmount?.(),this.emit("#unmounted"),this._copper?.destroy()})}emit(Q,X){this.dispatchEvent(new CustomEvent(`copper:${Q}`,{detail:X}))}}export{BQ as watch,Q0 as unref,uZ as text,vZ as svg,c as ref,g as readonly,rZ as reactiveProp,sZ as reactiveInputValue,cZ as reactiveIf,iZ as reactiveFor,L0 as reactive,aZ as listen,_0 as fragment,hZ as el,kZ as computed,lZ as attr,mZ as append,_X as CopperElement};
