var j0=function(Q,X){const Z=Object.create(null),J=Q.split(",");for(let $=0;$<J.length;$++)Z[J[$]]=!0;return X?($)=>!!Z[$.toLowerCase()]:($)=>!!Z[$]};var b=Object.freeze({}),EQ=Object.freeze([]),n=()=>{},H1=()=>!1;var x=Object.assign,E1=(Q,X)=>{const Z=Q.indexOf(X);if(Z>-1)Q.splice(Z,1)},jQ=Object.prototype.hasOwnProperty,H=(Q,X)=>jQ.call(Q,X),j=Array.isArray,h=(Q)=>F0(Q)==="[object Map]",j1=(Q)=>F0(Q)==="[object Set]";var z=(Q)=>typeof Q==="function",$0=(Q)=>typeof Q==="string",Y0=(Q)=>typeof Q==="symbol",V=(Q)=>Q!==null&&typeof Q==="object",F1=(Q)=>{return(V(Q)||z(Q))&&z(Q.then)&&z(Q.catch)},FQ=Object.prototype.toString,F0=(Q)=>FQ.call(Q),O0=(Q)=>{return F0(Q).slice(8,-1)},O1=(Q)=>F0(Q)==="[object Object]",z0=(Q)=>$0(Q)&&Q!=="NaN"&&Q[0]!=="-"&&""+parseInt(Q,10)===Q;var A0=(Q)=>{const X=Object.create(null);return(Z)=>{return X[Z]||(X[Z]=Q(Z))}},OQ=/-(\w)/g,zQ=A0((Q)=>{return Q.replace(OQ,(X,Z)=>Z?Z.toUpperCase():"")}),AQ=/\B([A-Z])/g,TQ=A0((Q)=>Q.replace(AQ,"-$1").toLowerCase()),T0=A0((Q)=>{return Q.charAt(0).toUpperCase()+Q.slice(1)}),z1=A0((Q)=>{return Q?`on${T0(Q)}`:""}),C=(Q,X)=>!Object.is(Q,X);var u0=(Q,X,Z)=>{Object.defineProperty(Q,X,{configurable:!0,enumerable:!1,value:Z})};var _1,P0=()=>{return _1||(_1=typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:{})};var PQ="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";var sX=j0(PQ+",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");var A1=function(Q,...X){console.warn(`[Vue warn] ${Q}`,...X)};var RQ=function(Q,X=x1){if(X&&X.active)X.effects.push(Q)},p0=function(){return x1};var T1=function(Q){const{deps:X}=Q;if(X.length){for(let Z=0;Z<X.length;Z++)X[Z].delete(Q);X.length=0}};var w0=function(){C1.push(u),u=!1};var f0=function(){const Q=C1.pop();u=Q===void 0?!0:Q},P=function(Q,X,Z){if(u&&T){let J=m0.get(Q);if(!J)m0.set(Q,J=new Map);let $=J.get(Z);if(!$)J.set(Z,$=i0());k1($,{effect:T,target:Q,type:X,key:Z})}},k1=function(Q,X){let Z=!1;if(q0<=l0){if(!f1(Q))Q.n|=m,Z=!w1(Q)}else Z=!Q.has(T);if(Z){if(Q.add(T),T.deps.push(Q),T.onTrack)T.onTrack(x({effect:T},X))}},k=function(Q,X,Z,J,$,Y){const q=m0.get(Q);if(!q)return;let D=[];if(X==="clear")D=[...q.values()];else if(Z==="length"&&j(Q)){const L=Number(J);q.forEach((K,U)=>{if(U==="length"||!Y0(U)&&U>=L)D.push(K)})}else{if(Z!==void 0)D.push(q.get(Z));switch(X){case"add":if(!j(Q)){if(D.push(q.get(r)),h(Q))D.push(q.get(d0))}else if(z0(Z))D.push(q.get("length"));break;case"delete":if(!j(Q)){if(D.push(q.get(r)),h(Q))D.push(q.get(d0))}break;case"set":if(h(Q))D.push(q.get(r));break}}const B={target:Q,type:X,key:Z,newValue:J,oldValue:$,oldTarget:Y};if(D.length===1){if(D[0])c0(D[0],B)}else{const L=[];for(let K of D)if(K)L.push(...K);c0(i0(L),B)}},c0=function(Q,X){const Z=j(Q)?Q:[...Q];for(let J of Z)if(J.computed)P1(J,X);for(let J of Z)if(!J.computed)P1(J,X)},P1=function(Q,X){if(Q!==T||Q.allowRecurse){if(Q.onTrigger)Q.onTrigger(x({effect:Q},X));if(Q.scheduler)Q.scheduler();else Q.run()}};var bQ=function(){const Q={};return["includes","indexOf","lastIndexOf"].forEach((X)=>{Q[X]=function(...Z){const J=M(this);for(let Y=0,q=this.length;Y<q;Y++)P(J,"get",Y+"");const $=J[X](...Z);if($===-1||$===!1)return J[X](...Z.map(M));else return $}}),["push","pop","shift","unshift","splice"].forEach((X)=>{Q[X]=function(...Z){w0();const J=M(this)[X].apply(this,Z);return f0(),J}}),Q},xQ=function(Q){const X=M(this);return P(X,"has",Q),X.hasOwnProperty(Q)},R0=function(Q,X,Z=!1,J=!1){Q=Q.__v_raw;const $=M(Q),Y=M(X);if(!Z){if(C(X,Y))P($,"get",X);P($,"get",Y)}const{has:q}=C0($),D=J?a0:Z?e0:U0;if(q.call($,X))return D(Q.get(X));else if(q.call($,Y))return D(Q.get(Y));else if(Q!==$)Q.get(X)},N0=function(Q,X=!1){const Z=this.__v_raw,J=M(Z),$=M(Q);if(!X){if(C(Q,$))P(J,"has",Q);P(J,"has",$)}return Q===$?Z.has(Q):Z.has(Q)||Z.has($)},I0=function(Q,X=!1){return Q=Q.__v_raw,!X&&P(M(Q),"iterate",r),Reflect.get(Q,"size",Q)},N1=function(Q){Q=M(Q);const X=M(this);if(!C0(X).has.call(X,Q))X.add(Q),k(X,"add",Q,Q);return this},I1=function(Q,X){X=M(X);const Z=M(this),{has:J,get:$}=C0(Z);let Y=J.call(Z,Q);if(!Y)Q=M(Q),Y=J.call(Z,Q);else y1(Z,J,Q);const q=$.call(Z,Q);if(Z.set(Q,X),!Y)k(Z,"add",Q,X);else if(C(X,q))k(Z,"set",Q,X,q);return this},V1=function(Q){const X=M(this),{has:Z,get:J}=C0(X);let $=Z.call(X,Q);if(!$)Q=M(Q),$=Z.call(X,Q);else y1(X,Z,Q);const Y=J?J.call(X,Q):void 0,q=X.delete(Q);if($)k(X,"delete",Q,void 0,Y);return q},b1=function(){const Q=M(this),X=Q.size!==0,Z=h(Q)?new Map(Q):new Set(Q),J=Q.clear();if(X)k(Q,"clear",void 0,void 0,Z);return J},V0=function(Q,X){return function Z(J,$){const Y=this,q=Y.__v_raw,D=M(q),B=X?a0:Q?e0:U0;return!Q&&P(D,"iterate",r),q.forEach((L,K)=>{return J.call($,B(L),B(K),Y)})}},b0=function(Q,X,Z){return function(...J){const $=this.__v_raw,Y=M($),q=h(Y),D=Q==="entries"||Q===Symbol.iterator&&q,B=Q==="keys"&&q,L=$[Q](...J),K=Z?a0:X?e0:U0;return!X&&P(Y,"iterate",B?d0:r),{next(){const{value:U,done:W}=L.next();return W?{value:U,done:W}:{value:D?[K(U[0]),K(U[1])]:K(U),done:W}},[Symbol.iterator](){return this}}}},v=function(Q){return function(...X){{const Z=X[0]?`on key "${X[0]}" `:"";console.warn(`${T0(Q)} operation ${Z}failed: target is readonly.`,M(this))}return Q==="delete"?!1:this}},kQ=function(){const Q={get(Y){return R0(this,Y)},get size(){return I0(this)},has:N0,add:N1,set:I1,delete:V1,clear:b1,forEach:V0(!1,!1)},X={get(Y){return R0(this,Y,!1,!0)},get size(){return I0(this)},has:N0,add:N1,set:I1,delete:V1,clear:b1,forEach:V0(!1,!0)},Z={get(Y){return R0(this,Y,!0)},get size(){return I0(this,!0)},has(Y){return N0.call(this,Y,!0)},add:v("add"),set:v("set"),delete:v("delete"),clear:v("clear"),forEach:V0(!0,!1)},J={get(Y){return R0(this,Y,!0,!0)},get size(){return I0(this,!0)},has(Y){return N0.call(this,Y,!0)},add:v("add"),set:v("set"),delete:v("delete"),clear:v("clear"),forEach:V0(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach((Y)=>{Q[Y]=b0(Y,!1,!1),Z[Y]=b0(Y,!0,!1),X[Y]=b0(Y,!1,!0),J[Y]=b0(Y,!0,!0)}),[Q,Z,X,J]},o0=function(Q,X){const Z=X?Q?hQ:yQ:Q?gQ:SQ;return(J,$,Y)=>{if($==="__v_isReactive")return!Q;else if($==="__v_isReadonly")return Q;else if($==="__v_raw")return J;return Reflect.get(H(Z,$)&&($ in J)?Z:J,$,Y)}},y1=function(Q,X,Z){const J=M(Z);if(J!==Z&&X.call(Q,J)){const $=O0(Q);console.warn(`Reactive ${$} contains both the raw and reactive versions of the same object${$==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}},dQ=function(Q){switch(Q){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}},cQ=function(Q){return Q.__v_skip||!Object.isExtensible(Q)?0:dQ(O0(Q))},D0=function(Q){if(S(Q))return Q;return t0(Q,!1,wQ,vQ,h1)};var l=function(Q){return t0(Q,!0,fQ,uQ,v1)},e=function(Q){return t0(Q,!0,CQ,mQ,u1)},t0=function(Q,X,Z,J,$){if(!V(Q))return console.warn(`value cannot be made reactive: ${String(Q)}`),Q;if(Q.__v_raw&&!(X&&Q.__v_isReactive))return Q;const Y=$.get(Q);if(Y)return Y;const q=cQ(Q);if(q===0)return Q;const D=new Proxy(Q,q===2?J:Z);return $.set(Q,D),D},d=function(Q){if(S(Q))return d(Q.__v_raw);return!!(Q&&Q.__v_isReactive)},S=function(Q){return!!(Q&&Q.__v_isReadonly)},Q0=function(Q){return!!(Q&&Q.__v_isShallow)};var M=function(Q){const X=Q&&Q.__v_raw;return X?M(X):Q},n0=function(Q){return u0(Q,"__v_skip",!0),Q},pQ=function(Q){if(u&&T)Q=M(Q),k1(Q.dep||(Q.dep=i0()),{target:Q,type:"get",key:"value"})},iQ=function(Q,X){Q=M(Q);const Z=Q.dep;if(Z)c0(Z,{target:Q,type:"set",key:"value",newValue:X})},F=function(Q){return!!(Q&&Q.__v_isRef===!0)},c=function(Q){return sQ(Q,!1)};var sQ=function(Q,X){if(F(Q))return Q;return new m1(Q,X)};var l1=function(Q){return F(Q)?Q.value:Q};var Q1=function(Q){return d(Q)?Q:new Proxy(Q,rQ)};var x1;var i0=(Q)=>{const X=new Set(Q);return X.w=0,X.n=0,X},w1=(Q)=>(Q.w&m)>0,f1=(Q)=>(Q.n&m)>0,NQ=({deps:Q})=>{if(Q.length)for(let X=0;X<Q.length;X++)Q[X].w|=m},IQ=(Q)=>{const{deps:X}=Q;if(X.length){let Z=0;for(let J=0;J<X.length;J++){const $=X[J];if(w1($)&&!f1($))$.delete(Q);else X[Z++]=$;$.w&=~m,$.n&=~m}X.length=Z}},m0=new WeakMap,q0=0,m=1,l0=30,T,r=Symbol("iterate"),d0=Symbol("Map key iterate");class x0{constructor(Q,X=null,Z){this.fn=Q,this.scheduler=X,this.active=!0,this.deps=[],this.parent=void 0,RQ(this,Z)}run(){if(!this.active)return this.fn();let Q=T,X=u;while(Q){if(Q===this)return;Q=Q.parent}try{if(this.parent=T,T=this,u=!0,m=1<<++q0,q0<=l0)NQ(this);else T1(this);return this.fn()}finally{if(q0<=l0)IQ(this);if(m=1<<--q0,T=this.parent,u=X,this.parent=void 0,this.deferStop)this.stop()}}stop(){if(T===this)this.deferStop=!0;else if(this.active){if(T1(this),this.onStop)this.onStop();this.active=!1}}}var u=!0,C1=[],VQ=j0("__proto__,__v_isRef,__isVue"),S1=new Set(Object.getOwnPropertyNames(Symbol).filter((Q)=>Q!=="arguments"&&Q!=="caller").map((Q)=>Symbol[Q]).filter(Y0)),R1=bQ();class s0{constructor(Q=!1,X=!1){this._isReadonly=Q,this._shallow=X}get(Q,X,Z){const J=this._isReadonly,$=this._shallow;if(X==="__v_isReactive")return!J;else if(X==="__v_isReadonly")return J;else if(X==="__v_isShallow")return $;else if(X==="__v_raw"&&Z===(J?$?u1:v1:$?lQ:h1).get(Q))return Q;const Y=j(Q);if(!J){if(Y&&H(R1,X))return Reflect.get(R1,X,Z);if(X==="hasOwnProperty")return xQ}const q=Reflect.get(Q,X,Z);if(Y0(X)?S1.has(X):VQ(X))return q;if(!J)P(Q,"get",X);if($)return q;if(F(q))return Y&&z0(X)?q:q.value;if(V(q))return J?l(q):D0(q);return q}}class g1 extends s0{constructor(Q=!1){super(!1,Q)}set(Q,X,Z,J){let $=Q[X];if(S($)&&F($)&&!F(Z))return!1;if(!this._shallow){if(!Q0(Z)&&!S(Z))$=M($),Z=M(Z);if(!j(Q)&&F($)&&!F(Z))return $.value=Z,!0}const Y=j(Q)&&z0(X)?Number(X)<Q.length:H(Q,X),q=Reflect.set(Q,X,Z,J);if(Q===M(J)){if(!Y)k(Q,"add",X,Z);else if(C(Z,$))k(Q,"set",X,Z,$)}return q}deleteProperty(Q,X){const Z=H(Q,X),J=Q[X],$=Reflect.deleteProperty(Q,X);if($&&Z)k(Q,"delete",X,void 0,J);return $}has(Q,X){const Z=Reflect.has(Q,X);if(!Y0(X)||!S1.has(X))P(Q,"has",X);return Z}ownKeys(Q){return P(Q,"iterate",j(Q)?"length":r),Reflect.ownKeys(Q)}}class r0 extends s0{constructor(Q=!1){super(!0,Q)}set(Q,X){return A1(`Set operation on key "${String(X)}" failed: target is readonly.`,Q),!0}deleteProperty(Q,X){return A1(`Delete operation on key "${String(X)}" failed: target is readonly.`,Q),!0}}var wQ=new g1,fQ=new r0;var CQ=new r0(!0),a0=(Q)=>Q,C0=(Q)=>Reflect.getPrototypeOf(Q),[SQ,gQ,yQ,hQ]=kQ(),vQ={get:o0(!1,!1)};var uQ={get:o0(!0,!1)},mQ={get:o0(!0,!0)},h1=new WeakMap,lQ=new WeakMap,v1=new WeakMap,u1=new WeakMap,U0=(Q)=>V(Q)?D0(Q):Q,e0=(Q)=>V(Q)?l(Q):Q;class m1{constructor(Q,X){this.__v_isShallow=X,this.dep=void 0,this.__v_isRef=!0,this._rawValue=X?Q:M(Q),this._value=X?Q:U0(Q)}get value(){return pQ(this),this._value}set value(Q){const X=this.__v_isShallow||Q0(Q)||S(Q);if(Q=X?Q:M(Q),C(Q,this._rawValue))this._rawValue=Q,this._value=X?Q:U0(Q),iQ(this,Q)}}var rQ={get:(Q,X,Z)=>l1(Reflect.get(Q,X,Z)),set:(Q,X,Z,J)=>{const $=Q[X];if(F($)&&!F(Z))return $.value=Z,!0;else return Reflect.set(Q,X,Z,J)}};var nQ=function(Q){a.push(Q)},eQ=function(){a.pop()},O=function(Q,...X){w0();const Z=a.length?a[a.length-1].component:null,J=Z&&Z.appContext.config.warnHandler,$=QX();if(J)o(J,Z,11,[Q+X.join(""),Z&&Z.proxy,$.map(({vnode:Y})=>`at <${LQ(Z,Y.type)}>`).join("\n"),$]);else{const Y=[`[Vue warn]: ${Q}`,...X];if($.length)Y.push(`
`,...XX($));console.warn(...Y)}f0()},QX=function(){let Q=a[a.length-1];if(!Q)return[];const X=[];while(Q){const Z=X[0];if(Z&&Z.vnode===Q)Z.recurseCount++;else X.push({vnode:Q,recurseCount:0});const J=Q.component&&Q.component.parent;Q=J&&J.vnode}return X},XX=function(Q){const X=[];return Q.forEach((Z,J)=>{X.push(...J===0?[]:[`
`],...ZX(Z))}),X},ZX=function({vnode:Q,recurseCount:X}){const Z=X>0?`... (${X} recursive calls)`:"",J=Q.component?Q.component.parent==null:!1,$=` at <${LQ(Q.component,Q.type,J)}`,Y=">"+Z;return Q.props?[$,...JX(Q.props),Y]:[$+Y]},JX=function(Q){const X=[],Z=Object.keys(Q);if(Z.slice(0,3).forEach((J)=>{X.push(...n1(J,Q[J]))}),Z.length>3)X.push(" ...");return X},n1=function(Q,X,Z){if($0(X))return X=JSON.stringify(X),Z?X:[`${Q}=${X}`];else if(typeof X==="number"||typeof X==="boolean"||X==null)return Z?X:[`${Q}=${X}`];else if(F(X))return X=n1(Q,M(X.value),!0),Z?X:[`${Q}=Ref<`,X,">"];else if(z(X))return[`${Q}=fn${X.name?`<${X.name}>`:""}`];else return X=M(X),Z?X:[`${Q}=`,X]};var o=function(Q,X,Z,J){let $;try{$=J?Q(...J):Q()}catch(Y){e1(Y,X,Z)}return $},K0=function(Q,X,Z,J){if(z(Q)){const Y=o(Q,X,Z,J);if(Y&&F1(Y))Y.catch((q)=>{e1(q,X,Z)});return Y}const $=[];for(let Y=0;Y<Q.length;Y++)$.push(K0(Q[Y],X,Z,J));return $},e1=function(Q,X,Z,J=!0){const $=X?X.vnode:null;if(X){let Y=X.parent;const q=X.proxy,D=D1[Z];while(Y){const L=Y.ec;if(L){for(let K=0;K<L.length;K++)if(L[K](Q,q,D)===!1)return}Y=Y.parent}const B=X.appContext.config.errorHandler;if(B){o(B,null,10,[Q,q,D]);return}}$X(Q,Z,$,J)},$X=function(Q,X,Z,J=!0){{const $=D1[X];if(Z)nQ(Z);if(O(`Unhandled error${$?` during execution of ${$}`:""}`),Z)eQ();if(J)throw Q;else console.error(Q)}},qX=function(Q){const X=L1||QQ;return Q?X.then(this?Q.bind(this):Q):X},UX=function(Q){let X=i+1,Z=w.length;while(X<Z){const J=X+Z>>>1,$=w[J],Y=G0($);if(Y<Q||Y===Q&&$.pre)X=J+1;else Z=J}return X},W1=function(Q){if(!w.length||!w.includes(Q,S0&&Q.allowRecurse?i+1:i)){if(Q.id==null)w.push(Q);else w.splice(UX(Q.id),0,Q);XQ()}},XQ=function(){if(!S0&&!$1)$1=!0,L1=QQ.then(JQ)};var ZQ=function(Q){if(!j(Q)){if(!f||!f.includes(Q,Q.allowRecurse?p+1:p))J0.push(Q)}else J0.push(...Q);XQ()};var DX=function(Q){if(J0.length){const X=[...new Set(J0)];if(J0.length=0,f){f.push(...X);return}f=X,Q=Q||new Map,f.sort((Z,J)=>G0(Z)-G0(J));for(p=0;p<f.length;p++){if($Q(Q,f[p]))continue;f[p]()}f=null,p=0}},JQ=function(Q){$1=!1,S0=!0,Q=Q||new Map,w.sort(LX);const X=(Z)=>$Q(Q,Z);try{for(i=0;i<w.length;i++){const Z=w[i];if(Z&&Z.active!==!1){if(X(Z))continue;o(Z,null,14)}}}finally{if(i=0,w.length=0,DX(Q),S0=!1,L1=null,w.length||J0.length)JQ(Q)}},$Q=function(Q,X){if(!Q.has(X))Q.set(X,1);else{const Z=Q.get(X);if(Z>YX){const J=X.ownerInstance,$=J&&DQ(J.type);return O(`Maximum recursive updates exceeded${$?` in component <${$}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`),!0}else Q.set(X,Z+1)}};var WX=function(Q,X){if(g0.has(Q))return!1;return g0.set(Q,{initialDef:M0(X),instances:new Set}),!0},M0=function(Q){return fX(Q)?Q.__vccOpts:Q},KX=function(Q,X){const Z=g0.get(Q);if(!Z)return;Z.initialDef.render=X,[...Z.instances].forEach((J)=>{if(X)J.render=X,M0(J.type).render=X;J.renderCache=[],d1=!0,J.update(),d1=!1})},MX=function(Q,X){const Z=g0.get(Q);if(!Z)return;X=M0(X),c1(Z.initialDef,X);const J=[...Z.instances];for(let $ of J){const Y=M0($.type);if(!L0.has(Y)){if(Y!==Z.initialDef)c1(Y,X);L0.add(Y)}if($.appContext.propsCache.delete($.type),$.appContext.emitsCache.delete($.type),$.appContext.optionsCache.delete($.type),$.ceReload)L0.add(Y),$.ceReload(X.styles),L0.delete(Y);else if($.parent)W1($.parent.update);else if($.appContext.reload)$.appContext.reload();else if(typeof window!=="undefined")window.location.reload();else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}ZQ(()=>{for(let $ of J)L0.delete(M0($.type))})},c1=function(Q,X){x(Q,X);for(let Z in Q)if(Z!=="__file"&&!(Z in X))delete Q[Z]},X1=function(Q){return(X,Z)=>{try{return Q(X,Z)}catch(J){console.error(J),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}};var GX=function(){BX=!0};var _X=function(Q,X){if(X&&X.pendingBranch)if(j(Q))X.effects.push(...Q);else X.effects.push(Q);else ZQ(Q)};var K1=function(Q,X,Z){if(!z(X))O("\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.");return YQ(Q,X,Z)},YQ=function(Q,X,{immediate:Z,deep:J,flush:$,onTrack:Y,onTrigger:q}=b){var D;if(!X){if(Z!==void 0)O('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');if(J!==void 0)O('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.')}const B=(_)=>{O("Invalid watch source: ",_,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},L=p0()===((D=g)==null?void 0:D.scope)?g:null;let K,U=!1,W=!1;if(F(Q))K=()=>Q.value,U=Q0(Q);else if(d(Q))K=()=>Q,J=!0;else if(j(Q))W=!0,U=Q.some((_)=>d(_)||Q0(_)),K=()=>Q.map((_)=>{if(F(_))return _.value;else if(d(_))return Z0(_);else if(z(_))return o(_,L,2);else B(_)});else if(z(Q))if(X)K=()=>o(Q,L,2);else K=()=>{if(L&&L.isUnmounted)return;if(G)G();return K0(Q,L,3,[E])};else K=n,B(Q);if(X&&J){const _=K;K=()=>Z0(_())}let G,E=(_)=>{G=I.onStop=()=>{o(_,L,4)}},A;if(UQ){if(E=n,!X)K();else if(Z)K0(X,L,3,[K(),W?[]:void 0,E]);if($==="sync"){const _=kX();A=_.__watcherHandles||(_.__watcherHandles=[])}else return n}let N=W?new Array(Q.length).fill(k0):k0;const s=()=>{if(!I.active)return;if(X){const _=I.run();if(J||U||(W?_.some((_Q,HQ)=>C(_Q,N[HQ])):C(_,N))){if(G)G();K0(X,L,3,[_,N===k0?void 0:W&&N[0]===k0?[]:N,E]),N=_}}else I.run()};s.allowRecurse=!!X;let E0;if($==="sync")E0=s;else if($==="post")E0=()=>o1(s,L&&L.suspense);else{if(s.pre=!0,L)s.id=L.uid;E0=()=>W1(s)}const I=new x0(K,E0);if(I.onTrack=Y,I.onTrigger=q,X)if(Z)s();else N=I.run();else if($==="post")o1(I.run.bind(I),L&&L.suspense);else I.run();const G1=()=>{if(I.stop(),L&&L.scope)E1(L.scope.effects,I)};if(A)A.push(G1);return G1},HX=function(Q,X,Z){const J=this.proxy,$=$0(Q)?Q.includes(".")?EX(J,Q):()=>J[Q]:Q.bind(J,J);let Y;if(z(X))Y=X;else Y=X.handler,Z=X;const q=g;U1(this);const D=YQ($,Y.bind(J),Z);if(q)U1(q);else qQ();return D},EX=function(Q,X){const Z=X.split(".");return()=>{let J=Q;for(let $=0;$<Z.length&&J;$++)J=J[Z[$]];return J}},Z0=function(Q,X){if(!V(Q)||Q.__v_skip)return Q;if(X=X||new Set,X.has(Q))return Q;if(X.add(Q),F(Q))Z0(Q.value,X);else if(j(Q))for(let Z=0;Z<Q.length;Z++)Z0(Q[Z],X);else if(j1(Q)||h(Q))Q.forEach((Z)=>{Z0(Z,X)});else if(O1(Q))for(let Z in Q)Z0(Q[Z],X);return Q};var jX=function(Q,X,Z=g,J=!1){if(Z){const $=Z[Q]||(Z[Q]=[]),Y=X.__weh||(X.__weh=(...q)=>{if(Z.isUnmounted)return;w0(),U1(Z);const D=K0(X,Z,Q,q);return qQ(),f0(),D});if(J)$.unshift(Y);else $.push(Y);return Y}else{const $=z1(D1[Q].replace(/ hook$/,""));O(`${$} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`+" If you are using async setup(), make sure to register lifecycle hooks before the first await statement.")}};var p1=function(Q){return j(Q)?Q.reduce((X,Z)=>(X[Z]=null,X),{}):Q};var AX=function(Q){const X=Q.type,{mixins:Z,extends:J}=X,{mixins:$,optionsCache:Y,config:{optionMergeStrategies:q}}=Q.appContext,D=Y.get(X);let B;if(D)B=D;else if(!$.length&&!Z&&!J)B=X;else{if(B={},$.length)$.forEach((L)=>y0(B,L,q,!0));y0(B,X,q)}if(V(X))Y.set(X,B);return B},y0=function(Q,X,Z,J=!1){const{mixins:$,extends:Y}=X;if(Y)y0(Q,Y,Z,!0);if($)$.forEach((q)=>y0(Q,q,Z,!0));for(let q in X)if(J&&q==="expose")O('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const D=TX[q]||Z&&Z[q];Q[q]=D?D(Q[q],X[q]):X[q]}return Q},i1=function(Q,X){if(!X)return Q;if(!Q)return X;return function Z(){return x(z(Q)?Q.call(this,this):Q,z(X)?X.call(this,this):X)}},PX=function(Q,X){return W0(s1(Q),s1(X))},s1=function(Q){if(j(Q)){const X={};for(let Z=0;Z<Q.length;Z++)X[Q[Z]]=Q[Z];return X}return Q},R=function(Q,X){return Q?[...new Set([].concat(Q,X))]:X},W0=function(Q,X){return Q?x(Object.create(null),Q,X):X},r1=function(Q,X){if(Q){if(j(Q)&&j(X))return[...new Set([...Q,...X])];return x(Object.create(null),p1(Q),p1(X!=null?X:{}))}else return X},RX=function(Q,X){if(!Q)return X;if(!X)return Q;const Z=x(Object.create(null),Q);for(let J in X)Z[J]=R(Q[J],X[J]);return Z},NX=function(){return{app:null,config:{isNativeTag:H1,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}};var IX=function(Q,X,Z=!1){const J=g||Y1;if(J||a1){const $=J?J.parent==null?J.vnode.appContext&&J.vnode.appContext.provides:J.parent.provides:a1._context.provides;if($&&(Q in $))return $[Q];else if(arguments.length>1)return Z&&z(X)?X.call(J&&J.proxy):X;else O(`injection "${String(Q)}" not found.`)}else O("inject() can only be used inside setup() or functional components.")};var VX=function(Q){return Q.vnode.shapeFlag&4};var bX=function(Q){if(Q.exposed)return Q.exposeProxy||(Q.exposeProxy=new Proxy(Q1(n0(Q.exposed)),{get(X,Z){if(Z in X)return X[Z];else if(Z in B0)return B0[Z](Q)},has(X,Z){return(Z in X)||(Z in B0)}}))},DQ=function(Q,X=!0){return z(Q)?Q.displayName||Q.name:Q.name||X&&Q.__name},LQ=function(Q,X,Z=!1){let J=DQ(X);if(!J&&X.__file){const $=X.__file.match(/([^/\\]+)\.\w+$/);if($)J=$[1]}if(!J&&Q&&Q.parent){const $=(Y)=>{for(let q in Y)if(Y[q]===X)return q};J=$(Q.components||Q.parent.type.components)||$(Q.appContext.components)}return J?wX(J):Z?"App":"Anonymous"},fX=function(Q){return z(Q)&&("__vccOpts"in Q)};var J1=function(Q){return!!(Q&&Q.__v_isShallow)},WQ=function(){if(typeof window==="undefined")return;const Q={style:"color:#3ba776"},X={style:"color:#0b1bc9"},Z={style:"color:#b62e24"},J={style:"color:#9d288c"},$={header(U){if(!V(U))return null;if(U.__isVue)return["div",Q,"VueInstance"];else if(F(U))return["div",{},["span",Q,K(U)],"<",D(U.value),">"];else if(d(U))return["div",{},["span",Q,J1(U)?"ShallowReactive":"Reactive"],"<",D(U),`>${S(U)?" (readonly)":""}`];else if(S(U))return["div",{},["span",Q,J1(U)?"ShallowReadonly":"Readonly"],"<",D(U),">"];return null},hasBody(U){return U&&U.__isVue},body(U){if(U&&U.__isVue)return["div",{},...Y(U.$)]}};function Y(U){const W=[];if(U.type.props&&U.props)W.push(q("props",M(U.props)));if(U.setupState!==b)W.push(q("setup",U.setupState));if(U.data!==b)W.push(q("data",M(U.data)));const G=B(U,"computed");if(G)W.push(q("computed",G));const E=B(U,"inject");if(E)W.push(q("injected",E));return W.push(["div",{},["span",{style:J.style+";opacity:0.66"},"$ (internal): "],["object",{object:U}]]),W}function q(U,W){if(W=x({},W),!Object.keys(W).length)return["span",{}];return["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},U],["div",{style:"padding-left:1.25em"},...Object.keys(W).map((G)=>{return["div",{},["span",J,G+": "],D(W[G],!1)]})]]}function D(U,W=!0){if(typeof U==="number")return["span",X,U];else if(typeof U==="string")return["span",Z,JSON.stringify(U)];else if(typeof U==="boolean")return["span",J,U];else if(V(U))return["object",{object:W?M(U):U}];else return["span",Z,String(U)]}function B(U,W){const G=U.type;if(z(G))return;const E={};for(let A in U.ctx)if(L(G,A,W))E[A]=U.ctx[A];return E}function L(U,W,G){const E=U[G];if(j(E)&&E.includes(W)||V(E)&&(W in E))return!0;if(U.extends&&L(U.extends,W,G))return!0;if(U.mixins&&U.mixins.some((A)=>L(A,W,G)))return!0}function K(U){if(J1(U))return"ShallowRef";if(U.effect)return"ComputedRef";return"Ref"}if(window.devtoolsFormatters)window.devtoolsFormatters.push($);else window.devtoolsFormatters=[$]};var a=[],D1={["sp"]:"serverPrefetch hook",["bc"]:"beforeCreate hook",["c"]:"created hook",["bm"]:"beforeMount hook",["m"]:"mounted hook",["bu"]:"beforeUpdate hook",["u"]:"updated",["bum"]:"beforeUnmount hook",["um"]:"unmounted hook",["a"]:"activated hook",["da"]:"deactivated hook",["ec"]:"errorCaptured hook",["rtc"]:"renderTracked hook",["rtg"]:"renderTriggered hook",[0]:"setup function",[1]:"render function",[2]:"watcher getter",[3]:"watcher callback",[4]:"watcher cleanup function",[5]:"native event handler",[6]:"component event handler",[7]:"vnode hook",[8]:"directive hook",[9]:"transition hook",[10]:"app errorHandler",[11]:"app warnHandler",[12]:"ref function",[13]:"async component loader",[14]:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"},S0=!1,$1=!1,w=[],i=0,J0=[],f=null,p=0,QQ=Promise.resolve(),L1=null,YX=100,G0=(Q)=>Q.id==null?Infinity:Q.id,LX=(Q,X)=>{const Z=G0(Q)-G0(X);if(Z===0){if(Q.pre&&!X.pre)return-1;if(X.pre&&!Q.pre)return 1}return Z},d1=!1,L0=new Set;P0().__VUE_HMR_RUNTIME__={createRecord:X1(WX),rerender:X1(KX),reload:X1(MX)};var g0=new Map;var Y1=null;var BX=!1;var k0={},zZ=Symbol("_leaveCb"),AZ=Symbol("_enterCb");/*! #__NO_SIDE_EFFECTS__ *//*! #__NO_SIDE_EFFECTS__ */var y=(Q)=>(X,Z=g)=>(!UQ||Q==="sp")&&jX(Q,(...J)=>X(...J),Z),TZ=y("bm"),PZ=y("m"),RZ=y("bu"),NZ=y("u"),IZ=y("bum"),VZ=y("um"),bZ=y("sp"),xZ=y("rtg"),wZ=y("rtc");var fZ=Symbol.for("v-ndc"),q1=(Q)=>{if(!Q)return null;if(VX(Q))return bX(Q)||Q.proxy;return q1(Q.parent)},B0=x(Object.create(null),{$:(Q)=>Q,$el:(Q)=>Q.vnode.el,$data:(Q)=>Q.data,$props:(Q)=>e(Q.props),$attrs:(Q)=>e(Q.attrs),$slots:(Q)=>e(Q.slots),$refs:(Q)=>e(Q.refs),$parent:(Q)=>q1(Q.parent),$root:(Q)=>q1(Q.root),$emit:(Q)=>Q.emit,$options:(Q)=>__VUE_OPTIONS_API__?AX(Q):Q.type,$forceUpdate:(Q)=>Q.f||(Q.f=()=>W1(Q.update)),$nextTick:(Q)=>Q.n||(Q.n=qX.bind(Q.proxy)),$watch:(Q)=>__VUE_OPTIONS_API__?HX.bind(Q):n}),FX=(Q)=>Q==="_"||Q==="$",Z1=(Q,X)=>Q!==b&&!Q.__isScriptSetup&&H(Q,X),OX={get({_:Q},X){const{ctx:Z,setupState:J,data:$,props:Y,accessCache:q,type:D,appContext:B}=Q;if(X==="__isVue")return!0;let L;if(X[0]!=="$"){const G=q[X];if(G!==void 0)switch(G){case 1:return J[X];case 2:return $[X];case 4:return Z[X];case 3:return Y[X]}else if(Z1(J,X))return q[X]=1,J[X];else if($!==b&&H($,X))return q[X]=2,$[X];else if((L=Q.propsOptions[0])&&H(L,X))return q[X]=3,Y[X];else if(Z!==b&&H(Z,X))return q[X]=4,Z[X];else if(!__VUE_OPTIONS_API__||zX)q[X]=0}const K=B0[X];let U,W;if(K){if(X==="$attrs")P(Q,"get",X),GX();else if(X==="$slots")P(Q,"get",X);return K(Q)}else if((U=D.__cssModules)&&(U=U[X]))return U;else if(Z!==b&&H(Z,X))return q[X]=4,Z[X];else if(W=B.config.globalProperties,H(W,X))return W[X];else if(Y1&&(!$0(X)||X.indexOf("__v")!==0)){if($!==b&&FX(X[0])&&H($,X))O(`Property ${JSON.stringify(X)} must be accessed via \$data because it starts with a reserved character ("\$" or "_") and is not proxied on the render context.`);else if(Q===Y1)O(`Property ${JSON.stringify(X)} was accessed during render but is not defined on instance.`)}},set({_:Q},X,Z){const{data:J,setupState:$,ctx:Y}=Q;if(Z1($,X))return $[X]=Z,!0;else if($.__isScriptSetup&&H($,X))return O(`Cannot mutate <script setup> binding "${X}" from Options API.`),!1;else if(J!==b&&H(J,X))return J[X]=Z,!0;else if(H(Q.props,X))return O(`Attempting to mutate prop "${X}". Props are readonly.`),!1;if(X[0]==="$"&&(X.slice(1)in Q))return O(`Attempting to mutate public property "${X}". Properties starting with \$ are reserved and readonly.`),!1;else if(X in Q.appContext.config.globalProperties)Object.defineProperty(Y,X,{enumerable:!0,configurable:!0,value:Z});else Y[X]=Z;return!0},has({_:{data:Q,setupState:X,accessCache:Z,ctx:J,appContext:$,propsOptions:Y}},q){let D;return!!Z[q]||Q!==b&&H(Q,q)||Z1(X,q)||(D=Y[0])&&H(D,q)||H(J,q)||H(B0,q)||H($.config.globalProperties,q)},defineProperty(Q,X,Z){if(Z.get!=null)Q._.accessCache[X]=0;else if(H(Z,"value"))this.set(Q,X,Z.value,null);return Reflect.defineProperty(Q,X,Z)}};OX.ownKeys=(Q)=>{return O("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(Q)};var zX=!0,TX={data:i1,props:r1,emits:r1,methods:W0,computed:W0,beforeCreate:R,created:R,beforeMount:R,mounted:R,beforeUpdate:R,updated:R,beforeDestroy:R,beforeUnmount:R,destroyed:R,unmounted:R,activated:R,deactivated:R,errorCaptured:R,serverPrefetch:R,components:W0,directives:W0,watch:RX,provide:i1,inject:PX};var a1=null;var o1=_X;var CZ=Symbol.for("v-fgt"),kZ=Symbol.for("v-txt"),SZ=Symbol.for("v-cmt"),gZ=Symbol.for("v-stc");var yZ=NX();var g=null;var M1,X0,t1="__VUE_INSTANCE_SETTERS__";{if(!(X0=P0()[t1]))X0=P0()[t1]=[];X0.push((Q)=>g=Q),M1=(Q)=>{if(X0.length>1)X0.forEach((X)=>X(Q));else X0[0](Q)}}var U1=(Q)=>{M1(Q),Q.scope.on()},qQ=()=>{g&&g.scope.off(),M1(null)};var UQ=!1;var xX=/(?:^|[-_])(\w)/g,wX=(Q)=>Q.replace(xX,(X)=>X.toUpperCase()).replace(/[-_]/g,"");var CX=Symbol.for("v-scx"),kX=()=>{{const Q=IX(CX);if(!Q)O("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");return Q}};var SX=function(){WQ()};SX();class _0{element;props={};#Q=[];constructor(Q){this.element=Q}watch(...Q){const X=K1(...Q);return this.#Q.push(X),X}listen(...Q){this.element.addEventListener(...Q);const X=()=>{this.element.removeEventListener(...Q)};return this.#Q.push(X),X}addWatcher(Q){this.#Q.push(Q)}destroy(){while(this.#Q.length>0)this.#Q.pop()();for(let Q of this.element.childNodes)Q._copper?.destroy();delete this.element._copper,this.element=null}}var B1=function(Q){Q._copper??=new _0(Q)};function gX(Q){const X=document.createElement(Q);return B1(X),X}function yX(Q=""){const X=document.createTextNode(Q);return B1(X),X}function H0(){return document.createDocumentFragment()}function h0(Q=""){const X=document.createComment(Q);return B1(X),X}var KQ=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootdelegatesfocus"]);function v0(Q){return typeof Q==="object"&&Q!==null&&Q.constructor===Object}function t(Q){if(F(Q))return Q.value;return Q}var MQ=function(Q){const X=new Set;if(typeof Q==="string")for(let Z of Q.split(" "))X.add(Z);else if(v0(Q)){for(let[Z,J]of Object.entries(Q))if(J)X.add(Z)}else if(Array.isArray(Q))for(let Z of Q)X.add(Z);return X};function BQ(Q,X,Z,J){if(KQ.has(X))if(Z)Q.setAttribute(X,"");else Q.removeAttribute(X);else if(X==="class"){const $=MQ(J);for(let Y of MQ(Z))Q.classList.add(Y),$.delete(Y);for(let Y of $)Q.classList.remove(Y)}else if(Z)Q.setAttribute(X,Z);else Q.removeAttribute(X)}function hX(Q,X,Z){Q._copper.watch(Z,(J,$)=>{BQ(Q,X,t(J),t($))},{deep:!0,immediate:!0})}var vX=function(Q,X){let Z=X,J=[];if(typeof Q==="function")J=Q();if(J.length===0)J.push(X);else Z=H0(),Z.append(...J);return[Z,J]};function uX(Q,X){const Z=h0(),J=Z._copper,$=[Z];return setTimeout(()=>{J.watch(Q,(Y)=>{const[q,D]=vX(X[Y],Z);while($.length>0){const B=$.pop();if($.length===0)B.replaceWith(q);else B.remove();if(B!==Z)B._copper?.destroy()}$.push(...D)},{immediate:!0})}),J.addWatcher(()=>{for(let Y of $)Y.remove(),Y._copper?.destroy();$.length=0}),Z}var mX=function(Q){if(v0(Q))return Object.entries(Q);if(Array.isArray(Q)||Q instanceof Map||Q instanceof Set)return Q.entries();if(typeof Q==="number"){const X=[];for(let Z=0;Z<Q;Z++)X.push([Z,Z]);return X}throw new TypeError("Cannot iterate over value")};function lX(Q,X,Z){const J=h0(),$=J._copper;let Y=J;const q=new Map,D=typeof X==="function";return setTimeout(()=>{$.watch(Q,(B)=>{const L=new Set(q.keys());if(Y!==J)Y.parentNode.insertBefore(J,Y);const K=H0();for(let[U,W]of mX(B)){const G=D?X(W,U):Symbol("");L.delete(G);let E,A,N;if(q.has(G))({ref_key:E,ref_value:A,elements:N}=q.get(G)),E.value=U,A.value=W;else E=c(U),A=c(W),N=Z(l(A),l(E));if(N.length===0)continue;K.append(...N),q.set(G,{ref_key:E,ref_value:A,elements:N})}for(let U of L){const{elements:W}=q.get(U);for(let G of W)G.remove(),G._copper?.destroy();q.delete(U)}if(K.childNodes.length===0)Y=J;else Y=K.firstChild,J.replaceWith(K)},{deep:!0,immediate:!0})}),$.addWatcher(()=>{for(let{elements:B}of q.values())for(let L of B)L.remove(),L._copper?.destroy();q.clear()}),J}function dX(Q,X){Q._copper.watch(X,(Z)=>{Q.value=t(Z)},{deep:!0,immediate:!0}),Q._copper.listen("input",()=>{X().value=Q.value})}function cX(Q,X){Q._copper.watch(X,(Z)=>{Q.textContent=String(t(Z))},{deep:!0,immediate:!0})}function pX(Q,X,Z){const J=Q._copper,$=c();J.watch(Z,(Y)=>{$.value=Y},{immediate:!0}),J.props[X]=l($)}function iX(Q,X,Z,J){J=new Set(J);const $={};if(J.has("once"))$.once=!0;if(J.has("passive"))$.passive=!0;if(J.has("capture"))$.capture=!0;const Y=[X,(q)=>{if(J.has("shift")&&!q.shiftKey)return;if(J.has("alt")&&!q.altKey)return;if(J.has("ctrl")&&!q.ctrlKey)return;if(J.has("meta")&&!q.metaKey)return;if(J.has("prevent"))q.preventDefault();if(J.has("stop"))q.stopPropagation();Z(J.has(".component")?q.detail:q)}];if(Object.keys($).length>0)Y.push($);Q._copper.listen(...Y)}class GQ extends HTMLElement{root;constructor(Q={}){super();const X=Q.shadow??"none";switch(X){case"open":case"closed":this.root=this.attachShadow({mode:X});break;case"none":this.root=this;break;default:throw new Error(`Invalid "shadow" option: "${Q.shadow}".`)}this._copper=new _0(this)}#Q=!1;_init(Q){this._render(this.root,Q)}_render(){throw new Error("No render method found.")}connectedCallback(){if(!this.#Q)this.#Q=!0,this._init();this.onMount?.()}disconnectedCallback(){}emit(Q,X){this.dispatchEvent(new CustomEvent(`copper:${Q}`,{detail:X}))}}export{K1 as watch,yX as text,c as ref,cX as reactiveTextNode,pX as reactiveProp,dX as reactiveInputValue,uX as reactiveIf,lX as reactiveFor,hX as reactiveAttr,D0 as reactive,iX as listen,H0 as fragment,gX as el,BQ as attr,GQ as CopperElement};
