var F0=function(Q,X){const Z=Object.create(null),$=Q.split(",");for(let J=0;J<$.length;J++)Z[$[J]]=!0;return X?(J)=>!!Z[J.toLowerCase()]:(J)=>!!Z[J]};var b=Object.freeze({}),AX=Object.freeze([]),t=()=>{},OQ=()=>!1;var w=Object.assign,zQ=(Q,X)=>{const Z=Q.indexOf(X);if(Z>-1)Q.splice(Z,1)},TX=Object.prototype.hasOwnProperty,E=(Q,X)=>TX.call(Q,X),_=Array.isArray,v=(Q)=>O0(Q)==="[object Map]",AQ=(Q)=>O0(Q)==="[object Set]";var F=(Q)=>typeof Q==="function",J0=(Q)=>typeof Q==="string",Y0=(Q)=>typeof Q==="symbol",V=(Q)=>Q!==null&&typeof Q==="object",TQ=(Q)=>{return(V(Q)||F(Q))&&F(Q.then)&&F(Q.catch)},PX=Object.prototype.toString,O0=(Q)=>PX.call(Q),z0=(Q)=>{return O0(Q).slice(8,-1)},PQ=(Q)=>O0(Q)==="[object Object]",A0=(Q)=>J0(Q)&&Q!=="NaN"&&Q[0]!=="-"&&""+parseInt(Q,10)===Q;var T0=(Q)=>{const X=Object.create(null);return(Z)=>{return X[Z]||(X[Z]=Q(Z))}},RX=/-(\w)/g,NX=T0((Q)=>{return Q.replace(RX,(X,Z)=>Z?Z.toUpperCase():"")}),IX=/\B([A-Z])/g,VX=T0((Q)=>Q.replace(IX,"-$1").toLowerCase()),P0=T0((Q)=>{return Q.charAt(0).toUpperCase()+Q.slice(1)}),RQ=T0((Q)=>{return Q?`on${P0(Q)}`:""}),C=(Q,X)=>!Object.is(Q,X);var l0=(Q,X,Z)=>{Object.defineProperty(Q,X,{configurable:!0,enumerable:!1,value:Z})};var FQ,R0=()=>{return FQ||(FQ=typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:{})};var bX="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";var eZ=F0(bX+",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");var NQ=function(Q,...X){console.warn(`[Vue warn] ${Q}`,...X)};var wX=function(Q,X=kQ){if(X&&X.active)X.effects.push(Q)},s0=function(){return kQ};var IQ=function(Q){const{deps:X}=Q;if(X.length){for(let Z=0;Z<X.length;Z++)X[Z].delete(Q);X.length=0}};var x0=function(){yQ.push(m),m=!1};var f0=function(){const Q=yQ.pop();m=Q===void 0?!0:Q},P=function(Q,X,Z){if(m&&T){let $=d0.get(Q);if(!$)d0.set(Q,$=new Map);let J=$.get(Z);if(!J)$.set(Z,J=r0());hQ(J,{effect:T,target:Q,type:X,key:Z})}},hQ=function(Q,X){let Z=!1;if(q0<=c0){if(!gQ(Q))Q.n|=l,Z=!SQ(Q)}else Z=!Q.has(T);if(Z){if(Q.add(T),T.deps.push(Q),T.onTrack)T.onTrack(w({effect:T},X))}},k=function(Q,X,Z,$,J,Y){const q=d0.get(Q);if(!q)return;let D=[];if(X==="clear")D=[...q.values()];else if(Z==="length"&&_(Q)){const L=Number($);q.forEach((B,U)=>{if(U==="length"||!Y0(U)&&U>=L)D.push(B)})}else{if(Z!==void 0)D.push(q.get(Z));switch(X){case"add":if(!_(Q)){if(D.push(q.get(r)),v(Q))D.push(q.get(p0))}else if(A0(Z))D.push(q.get("length"));break;case"delete":if(!_(Q)){if(D.push(q.get(r)),v(Q))D.push(q.get(p0))}break;case"set":if(v(Q))D.push(q.get(r));break}}const W={target:Q,type:X,key:Z,newValue:$,oldValue:J,oldTarget:Y};if(D.length===1){if(D[0])i0(D[0],W)}else{const L=[];for(let B of D)if(B)L.push(...B);i0(r0(L),W)}},i0=function(Q,X){const Z=_(Q)?Q:[...Q];for(let $ of Z)if($.computed)VQ($,X);for(let $ of Z)if(!$.computed)VQ($,X)},VQ=function(Q,X){if(Q!==T||Q.allowRecurse){if(Q.onTrigger)Q.onTrigger(w({effect:Q},X));if(Q.scheduler)Q.scheduler();else Q.run()}};var kX=function(){const Q={};return["includes","indexOf","lastIndexOf"].forEach((X)=>{Q[X]=function(...Z){const $=M(this);for(let Y=0,q=this.length;Y<q;Y++)P($,"get",Y+"");const J=$[X](...Z);if(J===-1||J===!1)return $[X](...Z.map(M));else return J}}),["push","pop","shift","unshift","splice"].forEach((X)=>{Q[X]=function(...Z){x0();const $=M(this)[X].apply(this,Z);return f0(),$}}),Q},SX=function(Q){const X=M(this);return P(X,"has",Q),X.hasOwnProperty(Q)},N0=function(Q,X,Z=!1,$=!1){Q=Q.__v_raw;const J=M(Q),Y=M(X);if(!Z){if(C(X,Y))P(J,"get",X);P(J,"get",Y)}const{has:q}=C0(J),D=$?t0:Z?XQ:U0;if(q.call(J,X))return D(Q.get(X));else if(q.call(J,Y))return D(Q.get(Y));else if(Q!==J)Q.get(X)},I0=function(Q,X=!1){const Z=this.__v_raw,$=M(Z),J=M(Q);if(!X){if(C(Q,J))P($,"has",Q);P($,"has",J)}return Q===J?Z.has(Q):Z.has(Q)||Z.has(J)},V0=function(Q,X=!1){return Q=Q.__v_raw,!X&&P(M(Q),"iterate",r),Reflect.get(Q,"size",Q)},wQ=function(Q){Q=M(Q);const X=M(this);if(!C0(X).has.call(X,Q))X.add(Q),k(X,"add",Q,Q);return this},xQ=function(Q,X){X=M(X);const Z=M(this),{has:$,get:J}=C0(Z);let Y=$.call(Z,Q);if(!Y)Q=M(Q),Y=$.call(Z,Q);else mQ(Z,$,Q);const q=J.call(Z,Q);if(Z.set(Q,X),!Y)k(Z,"add",Q,X);else if(C(X,q))k(Z,"set",Q,X,q);return this},fQ=function(Q){const X=M(this),{has:Z,get:$}=C0(X);let J=Z.call(X,Q);if(!J)Q=M(Q),J=Z.call(X,Q);else mQ(X,Z,Q);const Y=$?$.call(X,Q):void 0,q=X.delete(Q);if(J)k(X,"delete",Q,void 0,Y);return q},CQ=function(){const Q=M(this),X=Q.size!==0,Z=v(Q)?new Map(Q):new Set(Q),$=Q.clear();if(X)k(Q,"clear",void 0,void 0,Z);return $},b0=function(Q,X){return function Z($,J){const Y=this,q=Y.__v_raw,D=M(q),W=X?t0:Q?XQ:U0;return!Q&&P(D,"iterate",r),q.forEach((L,B)=>{return $.call(J,W(L),W(B),Y)})}},w0=function(Q,X,Z){return function(...$){const J=this.__v_raw,Y=M(J),q=v(Y),D=Q==="entries"||Q===Symbol.iterator&&q,W=Q==="keys"&&q,L=J[Q](...$),B=Z?t0:X?XQ:U0;return!X&&P(Y,"iterate",W?p0:r),{next(){const{value:U,done:K}=L.next();return K?{value:U,done:K}:{value:D?[B(U[0]),B(U[1])]:B(U),done:K}},[Symbol.iterator](){return this}}}},u=function(Q){return function(...X){{const Z=X[0]?`on key "${X[0]}" `:"";console.warn(`${P0(Q)} operation ${Z}failed: target is readonly.`,M(this))}return Q==="delete"?!1:this}},vX=function(){const Q={get(Y){return N0(this,Y)},get size(){return V0(this)},has:I0,add:wQ,set:xQ,delete:fQ,clear:CQ,forEach:b0(!1,!1)},X={get(Y){return N0(this,Y,!1,!0)},get size(){return V0(this)},has:I0,add:wQ,set:xQ,delete:fQ,clear:CQ,forEach:b0(!1,!0)},Z={get(Y){return N0(this,Y,!0)},get size(){return V0(this,!0)},has(Y){return I0.call(this,Y,!0)},add:u("add"),set:u("set"),delete:u("delete"),clear:u("clear"),forEach:b0(!0,!1)},$={get(Y){return N0(this,Y,!0,!0)},get size(){return V0(this,!0)},has(Y){return I0.call(this,Y,!0)},add:u("add"),set:u("set"),delete:u("delete"),clear:u("clear"),forEach:b0(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach((Y)=>{Q[Y]=w0(Y,!1,!1),Z[Y]=w0(Y,!0,!1),X[Y]=w0(Y,!1,!0),$[Y]=w0(Y,!0,!0)}),[Q,Z,X,$]},n0=function(Q,X){const Z=X?Q?dX:lX:Q?mX:uX;return($,J,Y)=>{if(J==="__v_isReactive")return!Q;else if(J==="__v_isReadonly")return Q;else if(J==="__v_raw")return $;return Reflect.get(E(Z,J)&&J in $?Z:$,J,Y)}},mQ=function(Q,X,Z){const $=M(Z);if($!==Z&&X.call(Q,$)){const J=z0(Q);console.warn(`Reactive ${J} contains both the raw and reactive versions of the same object${J==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}},rX=function(Q){switch(Q){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}},aX=function(Q){return Q.__v_skip||!Object.isExtensible(Q)?0:rX(z0(Q))},L0=function(Q){if(S(Q))return Q;return e0(Q,!1,gX,cX,lQ)};var g=function(Q){return e0(Q,!0,yX,pX,dQ)},n=function(Q){return e0(Q,!0,hX,iX,cQ)},e0=function(Q,X,Z,$,J){if(!V(Q))return console.warn(`value cannot be made reactive: ${String(Q)}`),Q;if(Q.__v_raw&&!(X&&Q.__v_isReactive))return Q;const Y=J.get(Q);if(Y)return Y;const q=aX(Q);if(q===0)return Q;const D=new Proxy(Q,q===2?$:Z);return J.set(Q,D),D},d=function(Q){if(S(Q))return d(Q.__v_raw);return!!(Q&&Q.__v_isReactive)},S=function(Q){return!!(Q&&Q.__v_isReadonly)},e=function(Q){return!!(Q&&Q.__v_isShallow)};var M=function(Q){const X=Q&&Q.__v_raw;return X?M(X):Q},QQ=function(Q){return l0(Q,"__v_skip",!0),Q},pQ=function(Q){if(m&&T)Q=M(Q),hQ(Q.dep||(Q.dep=r0()),{target:Q,type:"get",key:"value"})},iQ=function(Q,X){Q=M(Q);const Z=Q.dep;if(Z)i0(Z,{target:Q,type:"set",key:"value",newValue:X})},z=function(Q){return!!(Q&&Q.__v_isRef===!0)},c=function(Q){return oX(Q,!1)};var oX=function(Q,X){if(z(Q))return Q;return new sQ(Q,X)};var Q0=function(Q){return z(Q)?Q.value:Q};var ZQ=function(Q){return d(Q)?Q:new Proxy(Q,tX)};var aQ=function(Q,X,Z=!1){let $,J;const Y=F(Q);if(Y)$=Q,J=()=>{console.warn("Write operation failed: computed value is readonly")};else $=Q.get,J=Q.set;const q=new rQ($,J,Y||!J,Z);if(X&&!Z)q.effect.onTrack=X.onTrack,q.effect.onTrigger=X.onTrigger;return q};var kQ;var r0=(Q)=>{const X=new Set(Q);return X.w=0,X.n=0,X},SQ=(Q)=>(Q.w&l)>0,gQ=(Q)=>(Q.n&l)>0,xX=({deps:Q})=>{if(Q.length)for(let X=0;X<Q.length;X++)Q[X].w|=l},fX=(Q)=>{const{deps:X}=Q;if(X.length){let Z=0;for(let $=0;$<X.length;$++){const J=X[$];if(SQ(J)&&!gQ(J))J.delete(Q);else X[Z++]=J;J.w&=~l,J.n&=~l}X.length=Z}},d0=new WeakMap,q0=0,l=1,c0=30,T,r=Symbol("iterate"),p0=Symbol("Map key iterate");class D0{constructor(Q,X=null,Z){this.fn=Q,this.scheduler=X,this.active=!0,this.deps=[],this.parent=void 0,wX(this,Z)}run(){if(!this.active)return this.fn();let Q=T,X=m;while(Q){if(Q===this)return;Q=Q.parent}try{if(this.parent=T,T=this,m=!0,l=1<<++q0,q0<=c0)xX(this);else IQ(this);return this.fn()}finally{if(q0<=c0)fX(this);if(l=1<<--q0,T=this.parent,m=X,this.parent=void 0,this.deferStop)this.stop()}}stop(){if(T===this)this.deferStop=!0;else if(this.active){if(IQ(this),this.onStop)this.onStop();this.active=!1}}}var m=!0,yQ=[],CX=F0("__proto__,__v_isRef,__isVue"),vQ=new Set(Object.getOwnPropertyNames(Symbol).filter((Q)=>Q!=="arguments"&&Q!=="caller").map((Q)=>Symbol[Q]).filter(Y0)),bQ=kX();class a0{constructor(Q=!1,X=!1){this._isReadonly=Q,this._shallow=X}get(Q,X,Z){const $=this._isReadonly,J=this._shallow;if(X==="__v_isReactive")return!$;else if(X==="__v_isReadonly")return $;else if(X==="__v_isShallow")return J;else if(X==="__v_raw"&&Z===($?J?cQ:dQ:J?sX:lQ).get(Q))return Q;const Y=_(Q);if(!$){if(Y&&E(bQ,X))return Reflect.get(bQ,X,Z);if(X==="hasOwnProperty")return SX}const q=Reflect.get(Q,X,Z);if(Y0(X)?vQ.has(X):CX(X))return q;if(!$)P(Q,"get",X);if(J)return q;if(z(q))return Y&&A0(X)?q:q.value;if(V(q))return $?g(q):L0(q);return q}}class uQ extends a0{constructor(Q=!1){super(!1,Q)}set(Q,X,Z,$){let J=Q[X];if(S(J)&&z(J)&&!z(Z))return!1;if(!this._shallow){if(!e(Z)&&!S(Z))J=M(J),Z=M(Z);if(!_(Q)&&z(J)&&!z(Z))return J.value=Z,!0}const Y=_(Q)&&A0(X)?Number(X)<Q.length:E(Q,X),q=Reflect.set(Q,X,Z,$);if(Q===M($)){if(!Y)k(Q,"add",X,Z);else if(C(Z,J))k(Q,"set",X,Z,J)}return q}deleteProperty(Q,X){const Z=E(Q,X),$=Q[X],J=Reflect.deleteProperty(Q,X);if(J&&Z)k(Q,"delete",X,void 0,$);return J}has(Q,X){const Z=Reflect.has(Q,X);if(!Y0(X)||!vQ.has(X))P(Q,"has",X);return Z}ownKeys(Q){return P(Q,"iterate",_(Q)?"length":r),Reflect.ownKeys(Q)}}class o0 extends a0{constructor(Q=!1){super(!0,Q)}set(Q,X){return NQ(`Set operation on key "${String(X)}" failed: target is readonly.`,Q),!0}deleteProperty(Q,X){return NQ(`Delete operation on key "${String(X)}" failed: target is readonly.`,Q),!0}}var gX=new uQ,yX=new o0;var hX=new o0(!0),t0=(Q)=>Q,C0=(Q)=>Reflect.getPrototypeOf(Q),[uX,mX,lX,dX]=vX(),cX={get:n0(!1,!1)};var pX={get:n0(!0,!1)},iX={get:n0(!0,!0)},lQ=new WeakMap,sX=new WeakMap,dQ=new WeakMap,cQ=new WeakMap,U0=(Q)=>V(Q)?L0(Q):Q,XQ=(Q)=>V(Q)?g(Q):Q;class sQ{constructor(Q,X){this.__v_isShallow=X,this.dep=void 0,this.__v_isRef=!0,this._rawValue=X?Q:M(Q),this._value=X?Q:U0(Q)}get value(){return pQ(this),this._value}set value(Q){const X=this.__v_isShallow||e(Q)||S(Q);if(Q=X?Q:M(Q),C(Q,this._rawValue))this._rawValue=Q,this._value=X?Q:U0(Q),iQ(this,Q)}}var tX={get:(Q,X,Z)=>Q0(Reflect.get(Q,X,Z)),set:(Q,X,Z,$)=>{const J=Q[X];if(z(J)&&!z(Z))return J.value=Z,!0;else return Reflect.set(Q,X,Z,$)}};class rQ{constructor(Q,X,Z,$){this._setter=X,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new D0(Q,()=>{if(!this._dirty)this._dirty=!0,iQ(this)}),this.effect.computed=this,this.effect.active=this._cacheable=!$,this.__v_isReadonly=Z}get value(){const Q=M(this);if(pQ(Q),Q._dirty||!Q._cacheable)Q._dirty=!1,Q._value=Q.effect.run();return Q._value}set value(Q){this._setter(Q)}}var XZ=function(Q){a.push(Q)},ZZ=function(){a.pop()},O=function(Q,...X){x0();const Z=a.length?a[a.length-1].component:null,$=Z&&Z.appContext.config.warnHandler,J=$Z();if($)o($,Z,11,[Q+X.join(""),Z&&Z.proxy,J.map(({vnode:Y})=>`at <${HX(Z,Y.type)}>`).join("\n"),J]);else{const Y=[`[Vue warn]: ${Q}`,...X];if(J.length)Y.push(`
`,...JZ(J));console.warn(...Y)}f0()},$Z=function(){let Q=a[a.length-1];if(!Q)return[];const X=[];while(Q){const Z=X[0];if(Z&&Z.vnode===Q)Z.recurseCount++;else X.push({vnode:Q,recurseCount:0});const $=Q.component&&Q.component.parent;Q=$&&$.vnode}return X},JZ=function(Q){const X=[];return Q.forEach((Z,$)=>{X.push(...$===0?[]:[`
`],...YZ(Z))}),X},YZ=function({vnode:Q,recurseCount:X}){const Z=X>0?`... (${X} recursive calls)`:"",$=Q.component?Q.component.parent==null:!1,J=` at <${HX(Q.component,Q.type,$)}`,Y=">"+Z;return Q.props?[J,...qZ(Q.props),Y]:[J+Y]},qZ=function(Q){const X=[],Z=Object.keys(Q);if(Z.slice(0,3).forEach(($)=>{X.push(...YX($,Q[$]))}),Z.length>3)X.push(" ...");return X},YX=function(Q,X,Z){if(J0(X))return X=JSON.stringify(X),Z?X:[`${Q}=${X}`];else if(typeof X==="number"||typeof X==="boolean"||X==null)return Z?X:[`${Q}=${X}`];else if(z(X))return X=YX(Q,M(X.value),!0),Z?X:[`${Q}=Ref<`,X,">"];else if(F(X))return[`${Q}=fn${X.name?`<${X.name}>`:""}`];else return X=M(X),Z?X:[`${Q}=`,X]};var o=function(Q,X,Z,$){let J;try{J=$?Q(...$):Q()}catch(Y){qX(Y,X,Z)}return J},M0=function(Q,X,Z,$){if(F(Q)){const Y=o(Q,X,Z,$);if(Y&&TQ(Y))Y.catch((q)=>{qX(q,X,Z)});return Y}const J=[];for(let Y=0;Y<Q.length;Y++)J.push(M0(Q[Y],X,Z,$));return J},qX=function(Q,X,Z,$=!0){const J=X?X.vnode:null;if(X){let Y=X.parent;const q=X.proxy,D=WQ[Z];while(Y){const L=Y.ec;if(L){for(let B=0;B<L.length;B++)if(L[B](Q,q,D)===!1)return}Y=Y.parent}const W=X.appContext.config.errorHandler;if(W){o(W,null,10,[Q,q,D]);return}}UZ(Q,Z,J,$)},UZ=function(Q,X,Z,$=!0){{const J=WQ[X];if(Z)XZ(Z);if(O(`Unhandled error${J?` during execution of ${J}`:""}`),Z)ZZ();if($)throw Q;else console.error(Q)}},LZ=function(Q){const X=KQ||UX;return Q?X.then(this?Q.bind(this):Q):X},WZ=function(Q){let X=i+1,Z=x.length;while(X<Z){const $=X+Z>>>1,J=x[$],Y=H0(J);if(Y<Q||Y===Q&&J.pre)X=$+1;else Z=$}return X},MQ=function(Q){if(!x.length||!x.includes(Q,S0&&Q.allowRecurse?i+1:i)){if(Q.id==null)x.push(Q);else x.splice(WZ(Q.id),0,Q);DX()}},DX=function(){if(!S0&&!qQ)qQ=!0,KQ=UX.then(WX)};var LX=function(Q){if(!_(Q)){if(!f||!f.includes(Q,Q.allowRecurse?p+1:p))$0.push(Q)}else $0.push(...Q);DX()};var KZ=function(Q){if($0.length){const X=[...new Set($0)];if($0.length=0,f){f.push(...X);return}f=X,Q=Q||new Map,f.sort((Z,$)=>H0(Z)-H0($));for(p=0;p<f.length;p++){if(KX(Q,f[p]))continue;f[p]()}f=null,p=0}},WX=function(Q){qQ=!1,S0=!0,Q=Q||new Map,x.sort(MZ);const X=(Z)=>KX(Q,Z);try{for(i=0;i<x.length;i++){const Z=x[i];if(Z&&Z.active!==!1){if(X(Z))continue;o(Z,null,14)}}}finally{if(i=0,x.length=0,KZ(Q),S0=!1,KQ=null,x.length||$0.length)WX(Q)}},KX=function(Q,X){if(!Q.has(X))Q.set(X,1);else{const Z=Q.get(X);if(Z>DZ){const $=X.ownerInstance,J=$&&GX($.type);return O(`Maximum recursive updates exceeded${J?` in component <${J}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`),!0}else Q.set(X,Z+1)}};var BZ=function(Q,X){if(g0.has(Q))return!1;return g0.set(Q,{initialDef:B0(X),instances:new Set}),!0},B0=function(Q){return SZ(Q)?Q.__vccOpts:Q},GZ=function(Q,X){const Z=g0.get(Q);if(!Z)return;Z.initialDef.render=X,[...Z.instances].forEach(($)=>{if(X)$.render=X,B0($.type).render=X;$.renderCache=[],oQ=!0,$.update(),oQ=!1})},HZ=function(Q,X){const Z=g0.get(Q);if(!Z)return;X=B0(X),tQ(Z.initialDef,X);const $=[...Z.instances];for(let J of $){const Y=B0(J.type);if(!W0.has(Y)){if(Y!==Z.initialDef)tQ(Y,X);W0.add(Y)}if(J.appContext.propsCache.delete(J.type),J.appContext.emitsCache.delete(J.type),J.appContext.optionsCache.delete(J.type),J.ceReload)W0.add(Y),J.ceReload(X.styles),W0.delete(Y);else if(J.parent)MQ(J.parent.update);else if(J.appContext.reload)J.appContext.reload();else if(typeof window!=="undefined")window.location.reload();else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}LX(()=>{for(let J of $)W0.delete(B0(J.type))})},tQ=function(Q,X){w(Q,X);for(let Z in Q)if(Z!=="__file"&&!(Z in X))delete Q[Z]},$Q=function(Q){return(X,Z)=>{try{return Q(X,Z)}catch($){console.error($),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}};var jZ=function(){EZ=!0};var _Z=function(Q,X){if(X&&X.pendingBranch)if(_(Q))X.effects.push(...Q);else X.effects.push(Q);else LX(Q)};var BQ=function(Q,X,Z){if(!F(X))O("\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.");return MX(Q,X,Z)},MX=function(Q,X,{immediate:Z,deep:$,flush:J,onTrack:Y,onTrigger:q}=b){var D;if(!X){if(Z!==void 0)O('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');if($!==void 0)O('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.')}const W=(H)=>{O("Invalid watch source: ",H,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},L=s0()===((D=y)==null?void 0:D.scope)?y:null;let B,U=!1,K=!1;if(z(Q))B=()=>Q.value,U=e(Q);else if(d(Q))B=()=>Q,$=!0;else if(_(Q))K=!0,U=Q.some((H)=>d(H)||e(H)),B=()=>Q.map((H)=>{if(z(H))return H.value;else if(d(H))return Z0(H);else if(F(H))return o(H,L,2);else W(H)});else if(F(Q))if(X)B=()=>o(Q,L,2);else B=()=>{if(L&&L.isUnmounted)return;if(G)G();return M0(Q,L,3,[j])};else B=t,W(Q);if(X&&$){const H=B;B=()=>Z0(H())}let G,j=(H)=>{G=I.onStop=()=>{o(H,L,4)}},A;if(HQ){if(j=t,!X)B();else if(Z)M0(X,L,3,[B(),K?[]:void 0,j]);if(J==="sync"){const H=hZ();A=H.__watcherHandles||(H.__watcherHandles=[])}else return t}let N=K?new Array(Q.length).fill(k0):k0;const s=()=>{if(!I.active)return;if(X){const H=I.run();if($||U||(K?H.some((OX,zX)=>C(OX,N[zX])):C(H,N))){if(G)G();M0(X,L,3,[H,N===k0?void 0:K&&N[0]===k0?[]:N,j]),N=H}}else I.run()};s.allowRecurse=!!X;let _0;if(J==="sync")_0=s;else if(J==="post")_0=()=>$X(s,L&&L.suspense);else{if(s.pre=!0,L)s.id=L.uid;_0=()=>MQ(s)}const I=new D0(B,_0);if(I.onTrack=Y,I.onTrigger=q,X)if(Z)s();else N=I.run();else if(J==="post")$X(I.run.bind(I),L&&L.suspense);else I.run();const _Q=()=>{if(I.stop(),L&&L.scope)zQ(L.scope.effects,I)};if(A)A.push(_Q);return _Q},FZ=function(Q,X,Z){const $=this.proxy,J=J0(Q)?Q.includes(".")?OZ($,Q):()=>$[Q]:Q.bind($,$);let Y;if(F(X))Y=X;else Y=X.handler,Z=X;const q=y;LQ(this);const D=MX(J,Y.bind($),Z);if(q)LQ(q);else BX();return D},OZ=function(Q,X){const Z=X.split(".");return()=>{let $=Q;for(let J=0;J<Z.length&&$;J++)$=$[Z[J]];return $}},Z0=function(Q,X){if(!V(Q)||Q.__v_skip)return Q;if(X=X||new Set,X.has(Q))return Q;if(X.add(Q),z(Q))Z0(Q.value,X);else if(_(Q))for(let Z=0;Z<Q.length;Z++)Z0(Q[Z],X);else if(AQ(Q)||v(Q))Q.forEach((Z)=>{Z0(Z,X)});else if(PQ(Q))for(let Z in Q)Z0(Q[Z],X);return Q};var zZ=function(Q,X,Z=y,$=!1){if(Z){const J=Z[Q]||(Z[Q]=[]),Y=X.__weh||(X.__weh=(...q)=>{if(Z.isUnmounted)return;x0(),LQ(Z);const D=M0(X,Z,Q,q);return BX(),f0(),D});if($)J.unshift(Y);else J.push(Y);return Y}else{const J=RQ(WQ[Q].replace(/ hook$/,""));O(`${J} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`+" If you are using async setup(), make sure to register lifecycle hooks before the first await statement.")}};var nQ=function(Q){return _(Q)?Q.reduce((X,Z)=>(X[Z]=null,X),{}):Q};var RZ=function(Q){const X=Q.type,{mixins:Z,extends:$}=X,{mixins:J,optionsCache:Y,config:{optionMergeStrategies:q}}=Q.appContext,D=Y.get(X);let W;if(D)W=D;else if(!J.length&&!Z&&!$)W=X;else{if(W={},J.length)J.forEach((L)=>y0(W,L,q,!0));y0(W,X,q)}if(V(X))Y.set(X,W);return W},y0=function(Q,X,Z,$=!1){const{mixins:J,extends:Y}=X;if(Y)y0(Q,Y,Z,!0);if(J)J.forEach((q)=>y0(Q,q,Z,!0));for(let q in X)if($&&q==="expose")O('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const D=NZ[q]||Z&&Z[q];Q[q]=D?D(Q[q],X[q]):X[q]}return Q},eQ=function(Q,X){if(!X)return Q;if(!Q)return X;return function Z(){return w(F(Q)?Q.call(this,this):Q,F(X)?X.call(this,this):X)}},IZ=function(Q,X){return K0(QX(Q),QX(X))},QX=function(Q){if(_(Q)){const X={};for(let Z=0;Z<Q.length;Z++)X[Q[Z]]=Q[Z];return X}return Q},R=function(Q,X){return Q?[...new Set([].concat(Q,X))]:X},K0=function(Q,X){return Q?w(Object.create(null),Q,X):X},XX=function(Q,X){if(Q){if(_(Q)&&_(X))return[...new Set([...Q,...X])];return w(Object.create(null),nQ(Q),nQ(X!=null?X:{}))}else return X},VZ=function(Q,X){if(!Q)return X;if(!X)return Q;const Z=w(Object.create(null),Q);for(let $ in X)Z[$]=R(Q[$],X[$]);return Z},bZ=function(){return{app:null,config:{isNativeTag:OQ,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}};var wZ=function(Q,X,Z=!1){const $=y||UQ;if($||ZX){const J=$?$.parent==null?$.vnode.appContext&&$.vnode.appContext.provides:$.parent.provides:ZX._context.provides;if(J&&Q in J)return J[Q];else if(arguments.length>1)return Z&&F(X)?X.call($&&$.proxy):X;else O(`injection "${String(Q)}" not found.`)}else O("inject() can only be used inside setup() or functional components.")};var xZ=function(Q){return Q.vnode.shapeFlag&4};var fZ=function(Q){if(Q.exposed)return Q.exposeProxy||(Q.exposeProxy=new Proxy(ZQ(QQ(Q.exposed)),{get(X,Z){if(Z in X)return X[Z];else if(Z in G0)return G0[Z](Q)},has(X,Z){return Z in X||Z in G0}}))},GX=function(Q,X=!0){return F(Q)?Q.displayName||Q.name:Q.name||X&&Q.__name},HX=function(Q,X,Z=!1){let $=GX(X);if(!$&&X.__file){const J=X.__file.match(/([^/\\]+)\.\w+$/);if(J)$=J[1]}if(!$&&Q&&Q.parent){const J=(Y)=>{for(let q in Y)if(Y[q]===X)return q};$=J(Q.components||Q.parent.type.components)||J(Q.appContext.components)}return $?kZ($):Z?"App":"Anonymous"},SZ=function(Q){return F(Q)&&"__vccOpts"in Q};var YQ=function(Q){return!!(Q&&Q.__v_isShallow)},EX=function(){if(typeof window==="undefined")return;const Q={style:"color:#3ba776"},X={style:"color:#0b1bc9"},Z={style:"color:#b62e24"},$={style:"color:#9d288c"},J={header(U){if(!V(U))return null;if(U.__isVue)return["div",Q,"VueInstance"];else if(z(U))return["div",{},["span",Q,B(U)],"<",D(U.value),">"];else if(d(U))return["div",{},["span",Q,YQ(U)?"ShallowReactive":"Reactive"],"<",D(U),`>${S(U)?" (readonly)":""}`];else if(S(U))return["div",{},["span",Q,YQ(U)?"ShallowReadonly":"Readonly"],"<",D(U),">"];return null},hasBody(U){return U&&U.__isVue},body(U){if(U&&U.__isVue)return["div",{},...Y(U.$)]}};function Y(U){const K=[];if(U.type.props&&U.props)K.push(q("props",M(U.props)));if(U.setupState!==b)K.push(q("setup",U.setupState));if(U.data!==b)K.push(q("data",M(U.data)));const G=W(U,"computed");if(G)K.push(q("computed",G));const j=W(U,"inject");if(j)K.push(q("injected",j));return K.push(["div",{},["span",{style:$.style+";opacity:0.66"},"$ (internal): "],["object",{object:U}]]),K}function q(U,K){if(K=w({},K),!Object.keys(K).length)return["span",{}];return["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},U],["div",{style:"padding-left:1.25em"},...Object.keys(K).map((G)=>{return["div",{},["span",$,G+": "],D(K[G],!1)]})]]}function D(U,K=!0){if(typeof U==="number")return["span",X,U];else if(typeof U==="string")return["span",Z,JSON.stringify(U)];else if(typeof U==="boolean")return["span",$,U];else if(V(U))return["object",{object:K?M(U):U}];else return["span",Z,String(U)]}function W(U,K){const G=U.type;if(F(G))return;const j={};for(let A in U.ctx)if(L(G,A,K))j[A]=U.ctx[A];return j}function L(U,K,G){const j=U[G];if(_(j)&&j.includes(K)||V(j)&&K in j)return!0;if(U.extends&&L(U.extends,K,G))return!0;if(U.mixins&&U.mixins.some((A)=>L(A,K,G)))return!0}function B(U){if(YQ(U))return"ShallowRef";if(U.effect)return"ComputedRef";return"Ref"}if(window.devtoolsFormatters)window.devtoolsFormatters.push(J);else window.devtoolsFormatters=[J]};var a=[],WQ={["sp"]:"serverPrefetch hook",["bc"]:"beforeCreate hook",["c"]:"created hook",["bm"]:"beforeMount hook",["m"]:"mounted hook",["bu"]:"beforeUpdate hook",["u"]:"updated",["bum"]:"beforeUnmount hook",["um"]:"unmounted hook",["a"]:"activated hook",["da"]:"deactivated hook",["ec"]:"errorCaptured hook",["rtc"]:"renderTracked hook",["rtg"]:"renderTriggered hook",[0]:"setup function",[1]:"render function",[2]:"watcher getter",[3]:"watcher callback",[4]:"watcher cleanup function",[5]:"native event handler",[6]:"component event handler",[7]:"vnode hook",[8]:"directive hook",[9]:"transition hook",[10]:"app errorHandler",[11]:"app warnHandler",[12]:"ref function",[13]:"async component loader",[14]:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"},S0=!1,qQ=!1,x=[],i=0,$0=[],f=null,p=0,UX=Promise.resolve(),KQ=null,DZ=100,H0=(Q)=>Q.id==null?Infinity:Q.id,MZ=(Q,X)=>{const Z=H0(Q)-H0(X);if(Z===0){if(Q.pre&&!X.pre)return-1;if(X.pre&&!Q.pre)return 1}return Z},oQ=!1,W0=new Set;R0().__VUE_HMR_RUNTIME__={createRecord:$Q(BZ),rerender:$Q(GZ),reload:$Q(HZ)};var g0=new Map;var UQ=null;var EZ=!1;var k0={},N4=Symbol("_leaveCb"),I4=Symbol("_enterCb");/*! #__NO_SIDE_EFFECTS__ *//*! #__NO_SIDE_EFFECTS__ */var h=(Q)=>(X,Z=y)=>(!HQ||Q==="sp")&&zZ(Q,(...$)=>X(...$),Z),V4=h("bm"),b4=h("m"),w4=h("bu"),x4=h("u"),f4=h("bum"),C4=h("um"),k4=h("sp"),S4=h("rtg"),g4=h("rtc");var y4=Symbol.for("v-ndc"),DQ=(Q)=>{if(!Q)return null;if(xZ(Q))return fZ(Q)||Q.proxy;return DQ(Q.parent)},G0=w(Object.create(null),{$:(Q)=>Q,$el:(Q)=>Q.vnode.el,$data:(Q)=>Q.data,$props:(Q)=>n(Q.props),$attrs:(Q)=>n(Q.attrs),$slots:(Q)=>n(Q.slots),$refs:(Q)=>n(Q.refs),$parent:(Q)=>DQ(Q.parent),$root:(Q)=>DQ(Q.root),$emit:(Q)=>Q.emit,$options:(Q)=>__VUE_OPTIONS_API__?RZ(Q):Q.type,$forceUpdate:(Q)=>Q.f||(Q.f=()=>MQ(Q.update)),$nextTick:(Q)=>Q.n||(Q.n=LZ.bind(Q.proxy)),$watch:(Q)=>__VUE_OPTIONS_API__?FZ.bind(Q):t}),AZ=(Q)=>Q==="_"||Q==="$",JQ=(Q,X)=>Q!==b&&!Q.__isScriptSetup&&E(Q,X),TZ={get({_:Q},X){const{ctx:Z,setupState:$,data:J,props:Y,accessCache:q,type:D,appContext:W}=Q;if(X==="__isVue")return!0;let L;if(X[0]!=="$"){const G=q[X];if(G!==void 0)switch(G){case 1:return $[X];case 2:return J[X];case 4:return Z[X];case 3:return Y[X]}else if(JQ($,X))return q[X]=1,$[X];else if(J!==b&&E(J,X))return q[X]=2,J[X];else if((L=Q.propsOptions[0])&&E(L,X))return q[X]=3,Y[X];else if(Z!==b&&E(Z,X))return q[X]=4,Z[X];else if(!__VUE_OPTIONS_API__||PZ)q[X]=0}const B=G0[X];let U,K;if(B){if(X==="$attrs")P(Q,"get",X),jZ();else if(X==="$slots")P(Q,"get",X);return B(Q)}else if((U=D.__cssModules)&&(U=U[X]))return U;else if(Z!==b&&E(Z,X))return q[X]=4,Z[X];else if(K=W.config.globalProperties,E(K,X))return K[X];else if(UQ&&(!J0(X)||X.indexOf("__v")!==0)){if(J!==b&&AZ(X[0])&&E(J,X))O(`Property ${JSON.stringify(X)} must be accessed via \$data because it starts with a reserved character ("\$" or "_") and is not proxied on the render context.`);else if(Q===UQ)O(`Property ${JSON.stringify(X)} was accessed during render but is not defined on instance.`)}},set({_:Q},X,Z){const{data:$,setupState:J,ctx:Y}=Q;if(JQ(J,X))return J[X]=Z,!0;else if(J.__isScriptSetup&&E(J,X))return O(`Cannot mutate <script setup> binding "${X}" from Options API.`),!1;else if($!==b&&E($,X))return $[X]=Z,!0;else if(E(Q.props,X))return O(`Attempting to mutate prop "${X}". Props are readonly.`),!1;if(X[0]==="$"&&X.slice(1)in Q)return O(`Attempting to mutate public property "${X}". Properties starting with \$ are reserved and readonly.`),!1;else if(X in Q.appContext.config.globalProperties)Object.defineProperty(Y,X,{enumerable:!0,configurable:!0,value:Z});else Y[X]=Z;return!0},has({_:{data:Q,setupState:X,accessCache:Z,ctx:$,appContext:J,propsOptions:Y}},q){let D;return!!Z[q]||Q!==b&&E(Q,q)||JQ(X,q)||(D=Y[0])&&E(D,q)||E($,q)||E(G0,q)||E(J.config.globalProperties,q)},defineProperty(Q,X,Z){if(Z.get!=null)Q._.accessCache[X]=0;else if(E(Z,"value"))this.set(Q,X,Z.value,null);return Reflect.defineProperty(Q,X,Z)}};TZ.ownKeys=(Q)=>{return O("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(Q)};var PZ=!0,NZ={data:eQ,props:XX,emits:XX,methods:K0,computed:K0,beforeCreate:R,created:R,beforeMount:R,mounted:R,beforeUpdate:R,updated:R,beforeDestroy:R,beforeUnmount:R,destroyed:R,unmounted:R,activated:R,deactivated:R,errorCaptured:R,serverPrefetch:R,components:K0,directives:K0,watch:VZ,provide:eQ,inject:IZ};var ZX=null;var $X=_Z;var h4=Symbol.for("v-fgt"),v4=Symbol.for("v-txt"),u4=Symbol.for("v-cmt"),m4=Symbol.for("v-stc");var l4=bZ();var y=null;var GQ,X0,JX="__VUE_INSTANCE_SETTERS__";{if(!(X0=R0()[JX]))X0=R0()[JX]=[];X0.push((Q)=>y=Q),GQ=(Q)=>{if(X0.length>1)X0.forEach((X)=>X(Q));else X0[0](Q)}}var LQ=(Q)=>{GQ(Q),Q.scope.on()},BX=()=>{y&&y.scope.off(),GQ(null)};var HQ=!1;var CZ=/(?:^|[-_])(\w)/g,kZ=(Q)=>Q.replace(CZ,(X)=>X.toUpperCase()).replace(/[-_]/g,""),gZ=(Q,X)=>{return aQ(Q,X,HQ)},yZ=Symbol.for("v-scx"),hZ=()=>{{const Q=wZ(yZ);if(!Q)O("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");return Q}};var vZ=function(){EX()};vZ();class E0{element;#Q=[];constructor(Q){this.element=Q}watch(...Q){const X=BQ(...Q);return this.#Q.push(X),X}listen(...Q){this.element.addEventListener(...Q);const X=()=>{this.element.removeEventListener(...Q)};return this.#Q.push(X),X}addWatcher(Q){this.#Q.push(Q)}destroy(){while(this.#Q.length>0)this.#Q.pop()();if(this.element){for(let Q of this.element.childNodes)Q._copper?.destroy();delete this.element._copper,this.element=null}}}var h0=function(Q){if(!Q._copper)Q._copper=new E0(Q)};function uZ(Q){const X=document.createElement(Q);return h0(X),X}function mZ(Q="svg"){const X=document.createElementNS("http://www.w3.org/2000/svg",Q);return h0(X),X}function lZ(Q){const X=typeof Q==="function",Z=document.createTextNode(X?"":Q??" ");if(h0(Z),X)Z._copper.watch(Q,($)=>{Z.textContent=String($)},{deep:!0,immediate:!0});return Z}function j0(){return document.createDocumentFragment()}function v0(Q=""){const X=document.createComment(Q);return h0(X),X}function dZ(Q,...X){return Q.append(...X),Q}var jX=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootdelegatesfocus"]);function u0(Q){return typeof Q==="object"&&Q!==null&&Q.constructor===Object}var m0=function(Q){const X=new Map;if(u0(Q)){for(let[Z,$]of Object.entries(Q))if($)X.set(Z,$)}else if(Array.isArray(Q))for(let Z of Q)X.set(Z,Z);return X},_X=function(Q,X,Z,$){if(jX.has(X))if(Z)Q.setAttribute(X,"");else Q.removeAttribute(X);else if(typeof Z==="string")Q.setAttribute(X,Z);else if(X==="class"){const J=m0($);for(let Y of m0(Z).keys())Q.classList.add(Y),J.delete(Y);for(let Y of J.keys())Q.classList.remove(Y)}else if(X==="style"){const J=m0($);for(let[Y,q]of m0(Z))Q.style.setProperty(Y,q),J.delete(Y);for(let Y of J.keys())Q.style.removeProperty(Y)}else if(Z!==null&&Z!==void 0)Q.setAttribute(X,Z);else Q.removeAttribute(X)};function cZ(Q,...X){for(let Z=0;Z<X.length;Z+=2){const $=X[Z],J=X[Z+1];if(typeof J==="function")Q._copper.watch(J,(Y,q)=>{_X(Q,$,Q0(Y),Q0(q))},{deep:!0,immediate:!0});else _X(Q,$,J)}return Q}var pZ=function(Q,X){let Z=X,$=[];if(typeof Q==="function")$=Q();if($.length===0)$.push(X);else Z=j0(),Z.append(...$);return[Z,$]};function iZ(Q,X){const Z=v0(),$=Z._copper,J=[Z];return setTimeout(()=>{$.watch(Q,(Y)=>{const[q,D]=pZ(X[Y],Z);while(J.length>0){const W=J.pop();if(J.length===0)W.replaceWith(q);else W.remove();if(W!==Z)W._copper?.destroy()}J.push(...D)},{immediate:!0})}),$.addWatcher(()=>{for(let Y of J)Y.remove(),Y._copper?.destroy();J.length=0}),Z}var sZ=function(Q){if(u0(Q))return Object.entries(Q);if(Array.isArray(Q)||Q instanceof Map||Q instanceof Set)return Q.entries();if(typeof Q==="number"){const X=[];for(let Z=0;Z<Q;Z++)X.push([Z,Z]);return X}throw new TypeError("Cannot iterate over value")};function rZ(Q,X,Z){const $=v0(),J=$._copper;let Y=$;const q=new Map,D=typeof X==="function";return setTimeout(()=>{J.watch(Q,(W)=>{const L=new Set(q.keys());if(Y!==$)Y.parentNode.insertBefore($,Y);const B=j0();for(let[U,K]of sZ(W)){const G=D?X(K,U):Symbol("");L.delete(G);let j,A,N;if(q.has(G))({ref_key:j,ref_value:A,elements:N}=q.get(G)),j.value=U,A.value=K;else j=c(U),A=c(K),N=Z(g(A),g(j));if(N.length===0)continue;B.append(...N),q.set(G,{ref_key:j,ref_value:A,elements:N})}for(let U of L){const{elements:K}=q.get(U);for(let G of K)G.remove(),G._copper?.destroy();q.delete(U)}if(B.childNodes.length===0)Y=$;else Y=B.firstChild,$.replaceWith(B)},{deep:!0,immediate:!0})}),J.addWatcher(()=>{for(let{elements:W}of q.values())for(let L of W)L.remove(),L._copper?.destroy();q.clear()}),$}function aZ(Q,X,Z){return Q._copper.watch(X,($)=>{Q.value=$},{deep:!0,immediate:!0}),Q._copper.listen("input",()=>{Z(Q.value)}),Q}function oZ(Q,...X){for(let Z=0;Z<X.length;Z+=2){const $=X[Z],J=X[Z+1];Q.bindProp($,J)}return Q}function tZ(Q,...X){for(let Z=0;Z<X.length;Z+=3){const $=X[Z],J=X[Z+1],Y=new Set(X[Z+2]),q={};if(Y.has("once"))q.once=!0;if(Y.has("passive"))q.passive=!0;if(Y.has("capture"))q.capture=!0;const D=[$,(W)=>{if(Y.has("shift")&&!W.shiftKey)return;if(Y.has("alt")&&!W.altKey)return;if(Y.has("ctrl")&&!W.ctrlKey)return;if(Y.has("meta")&&!W.metaKey)return;if(Y.has("prevent"))W.preventDefault();if(Y.has("stop"))W.stopPropagation();J(Y.has(".component")?W.detail:W)}];if(Object.keys(q).length>0)D.push(q);Q._copper.listen(...D)}return Q}var nZ=function(Q,X){const Z=document.createElement("style");Z.setAttribute("copper-component",Q),Z.textContent=X,document.head.append(Z)},EQ=Symbol("NO_VALUE");class FX extends HTMLElement{root;constructor(Q={}){super();if(typeof this.constructor.css==="string")nZ(this.tagName.toLowerCase(),this.constructor.css),delete this.constructor.css;this.innerHTML="";const X=Q.shadow??"none";switch(X){case"open":case"closed":this.root=this.attachShadow({mode:X});break;case"none":this.root=this;break;default:throw new Error(`Invalid "shadow" option: "${Q.shadow}".`)}this._copper=new E0(this)}#Q=!1;init(Q){try{this.render(Q)}catch(X){console.error(X)}}props={};#X=new Map;defineProps(Q){for(let[X,Z]of Object.entries(Q)){let $=EQ;if(this.hasAttribute(X))$=this.getAttribute(X);else if(this.hasAttribute(`${X}.number`))$=Number.parseFloat(this.getAttribute(`${X}.number`));else if(this.hasAttribute(`${X}.boolean`)){const q=this.getAttribute(`${X}.boolean`);$=q==="true"||q==="1"}const J=typeof Z==="function";if($!==EQ&&J&&Z($)!==!0)throw new jQ(this,X,$);const Y=c($===EQ?void 0:$);this.#X.set(X,{prop_ref:Y,validator:Z,is_validator_function:J}),this.props[X]=g(Y)}}bindProp(Q,X){if(this.#X.has(Q)!==!0){console.warn(`Property "${Q}" is not defined by component ${this.constructor.name}, so it cannot be passed to it.`);return}const{prop_ref:Z,validator:$,is_validator_function:J}=this.#X.get(Q);this._copper.watch(X,(Y)=>{if(J&&$(Y)!==!0)throw new jQ(this,Q,Y);Z.value=Y},{immediate:!0})}render(...Q){this.root.append(...Q)}#Z=!1;connectedCallback(){if(this.#Z===!1){if(this.#Z=!0,!this.#Q)this.#Q=!0,this.init();this.emit("#mounted")}}disconnectedCallback(){setTimeout(()=>{if(this.isConnected===!1)this.#Z=!1,this.onUnmount?.(),this.emit("#unmounted"),this._copper?.destroy()})}emit(Q,X){this.dispatchEvent(new CustomEvent(`copper:${Q}`,{detail:X}))}}class jQ extends TypeError{constructor(Q,X,Z){console.error("InvalidPropertyValueError happened on",Q);super(`Invalid value for property "${X}" on component ${Q.constructor.name}, got "${Z}" of type ${typeof Z}`);this.name="InvalidPropertyValueError"}}export{BQ as watch,Q0 as unref,lZ as text,mZ as svg,c as ref,g as readonly,oZ as reactiveProp,aZ as reactiveInputValue,iZ as reactiveIf,rZ as reactiveFor,L0 as reactive,tZ as listen,j0 as fragment,uZ as el,gZ as computed,cZ as attr,dZ as append,FX as CopperElement};
